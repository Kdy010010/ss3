<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"/>
<title>StarShield3: The cross of iron</title>
<style>
  :root{
    --bg1:#050014; --accent:#4af2c5; --danger:#ff4b81; --warn:#ffd166;
    --text:#f4f8ff; --sub:#a6b0ff;
    --panel:rgba(10,14,40,.92);
    --panel2:rgba(8,12,34,.88);
  }
  *{box-sizing:border-box;margin:0;padding:0;font-family:system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",sans-serif}
  body{
    min-height:100vh;display:flex;align-items:center;justify-content:center;
    background:radial-gradient(circle at top,#16193b 0,#050014 60%);
    color:var(--text);
  }
  .wrap{
    width:min(1320px,100vw - 16px);
    padding:14px 12px 16px;
    background:linear-gradient(145deg,rgba(10,12,40,.95),rgba(6,9,30,.95));
    border-radius:16px;border:1px solid rgba(90,120,255,.35);
    box-shadow:0 0 40px rgba(0,0,0,.9),0 0 24px rgba(61,214,255,.3);
    backdrop-filter:blur(12px)
  }
  .header{display:flex;justify-content:space-between;align-items:baseline;gap:8px;flex-wrap:wrap;margin-bottom:10px}
  .title{font-size:22px;font-weight:900;letter-spacing:.05em;text-transform:uppercase;display:flex;gap:10px;flex-wrap:wrap;align-items:baseline}
  .title span{font-size:13px;font-weight:500;color:var(--sub);text-transform:none;letter-spacing:0}
  .badge{padding:3px 10px;border-radius:999px;border:1px solid rgba(74,242,197,.6);color:var(--accent);font-size:11px;text-transform:uppercase;white-space:nowrap}

  .top{
    display:grid;
    grid-template-columns:repeat(7,minmax(0,1fr)) auto;
    gap:6px;align-items:center;margin-bottom:8px
  }
  .stat{background:var(--panel);border-radius:10px;padding:6px 8px;border:1px solid rgba(80,110,255,.45);min-width:0}
  .lab{font-size:10px;text-transform:uppercase;color:var(--sub);letter-spacing:.08em;white-space:nowrap}
  .val{margin-top:2px;font-size:16px;font-weight:900}
  .valSmall{margin-top:2px;font-size:12px;color:var(--sub);white-space:nowrap}
  .btn{
    background:radial-gradient(circle at top,#49f2c3,#18a3ff);
    border-radius:999px;padding:8px 14px;border:none;color:#02020c;
    font-size:11px;font-weight:950;letter-spacing:.06em;text-transform:uppercase;cursor:pointer;
    box-shadow:0 0 16px rgba(74,242,197,.6),0 0 8px rgba(24,163,255,.6);
    display:inline-flex;align-items:center;gap:6px;white-space:nowrap
  }
  .btn.secondary{background:rgba(12,18,50,.92);color:var(--text);border:1px solid rgba(110,144,255,.5);box-shadow:none}
  .btn.danger{background:rgba(255,75,129,.12); color:#ffdbe8; border:1px solid rgba(255,75,129,.5); box-shadow:none}
  .btn.good{background:rgba(74,242,197,.12); color:#d8fff3; border:1px solid rgba(74,242,197,.5); box-shadow:none}
  .btn:active{transform:translateY(1px) scale(.99)}
  .btnToggle{
    border-radius:999px;padding:10px 14px;
    border:1px solid rgba(110,144,255,.5);
    background:rgba(12,18,50,.92);
    color:var(--text);
    font-size:11px;font-weight:900;letter-spacing:.06em;text-transform:uppercase;
    display:inline-flex;align-items:center;gap:8px;cursor:pointer;
  }
  .btnToggle.on{
    border-color:rgba(74,242,197,.8);
    box-shadow:0 0 12px rgba(74,242,197,.35);
    color:#d8fff3;
  }

  .row{display:flex;gap:6px;flex-wrap:wrap;align-items:center;margin-bottom:8px}
  select{
    background:rgba(12,18,50,.92);
    border:1px solid rgba(110,144,255,.5);
    color:var(--text);border-radius:10px;padding:7px 10px;font-size:12px
  }
  .chip{
    background:rgba(12,18,50,.92);
    border:1px solid rgba(110,144,255,.5);
    border-radius:10px;padding:7px 10px;font-size:12px;
    display:flex;gap:8px;align-items:center
  }
  .chip b{color:var(--accent)}
  #game{
    display:block;width:100%;
    height:min(70vh, 720px);
    border-radius:14px;border:1px solid rgba(80,110,255,.8);
    box-shadow:0 0 18px rgba(74,242,197,.65);
    background:radial-gradient(circle at top,#141742 0,#030310 70%);
    touch-action:none;
  }

  .bars{display:grid;grid-template-columns:1fr 1fr;gap:8px;margin-top:8px}
  .barTitle{color:var(--sub);font-size:12px;letter-spacing:.04em;margin:2px 0 6px 2px}
  .gridCards{display:grid;grid-template-columns:repeat(3,minmax(0,1fr));gap:6px}
  .card{
    background:var(--panel);
    border-radius:12px;padding:8px 10px;border:1px solid rgba(80,110,255,.5);
    cursor:pointer;position:relative;overflow:hidden
  }
  .card:hover{box-shadow:0 0 12px rgba(74,242,197,.25)}
  .card.sel{border-color:var(--accent);box-shadow:0 0 14px rgba(74,242,197,.45)}
  .cardTop{display:flex;justify-content:space-between;align-items:center;gap:6px;margin-bottom:4px}
  .name{font-size:13px;font-weight:900}
  .key{font-size:10px;padding:1px 7px;border-radius:999px;border:1px solid rgba(180,196,255,.85);color:var(--sub)}
  .cost{font-size:12px;color:var(--accent);margin-bottom:4px}
  .desc{font-size:11px;color:var(--sub);line-height:1.25}

  .bottom{display:flex;justify-content:space-between;align-items:center;gap:8px;flex-wrap:wrap;margin-top:8px;color:var(--sub);font-size:11px}
  .pills{display:flex;gap:6px;flex-wrap:wrap;align-items:center}
  .pill{padding:4px 8px;border-radius:999px;background:rgba(12,18,50,.9);border:1px solid rgba(110,144,255,.5);font-size:10px}
  .kbd{padding:1px 6px;border-radius:4px;border:1px solid rgba(180,196,255,.8);font-size:9px;margin-right:4px}
  .status{min-height:16px;text-align:right;flex:1}
  .goodText{color:var(--accent)}
  .badText{color:var(--danger)}
  .warnText{color:var(--warn)}

  .modalBack{
    position:fixed; inset:0; background:rgba(0,0,0,.65);
    display:none; align-items:center; justify-content:center; padding:16px;
    z-index:50;
  }
  .modal{
    width:min(860px, 100%);
    background:linear-gradient(145deg, rgba(8,12,34,.96), rgba(6,8,24,.96));
    border:1px solid rgba(110,144,255,.55);
    border-radius:16px;
    box-shadow:0 0 28px rgba(0,0,0,.85), 0 0 18px rgba(74,242,197,.25);
    padding:14px 14px 12px;
  }
  .modal h2{font-size:18px; letter-spacing:.04em; margin-bottom:6px}
  .modal .sub{color:var(--sub); font-size:12px; margin-bottom:10px}
  .modal .text{
    background:rgba(10,14,40,.55);
    border:1px solid rgba(80,110,255,.35);
    border-radius:12px;
    padding:10px 12px;
    line-height:1.5;
    font-size:13px;
    color:#eaf0ff;
    white-space:pre-wrap;
    margin-bottom:10px;
  }
  .modal .row2{display:flex; gap:8px; align-items:center; justify-content:space-between; flex-wrap:wrap}
  .tag{
    display:inline-flex; gap:8px; align-items:center;
    padding:4px 10px; border-radius:999px;
    border:1px solid rgba(180,196,255,.55);
    background:rgba(12,18,50,.55);
    color:var(--sub); font-size:11px;
  }
  .tag b{color:var(--accent)}
  .miniHelp{color:var(--sub); font-size:11px}

  @media (max-width: 980px){
    .top{grid-template-columns:repeat(3,minmax(0,1fr)) auto}
    .bars{grid-template-columns:1fr}
    .gridCards{grid-template-columns:repeat(2,minmax(0,1fr))}
    .btn{padding:10px 14px}
    .chip{padding:9px 10px}
  }
</style>
</head>
<body>
<div class="wrap">
  <div class="header">
    <div class="title">
      StarShield3: ì² ê³¼ ì‹­ì
      <span>ë¯¸í•©ì¤‘êµ­ ë‹¬ì›ì •êµ°(í”Œë ˆì´ì–´) vs ì œ4ì œêµ­ ë‹¬êµ°(NAZI) Â· ë‹¬ ì•ë©´ ì „ì—­</span>
    </div>
    <div class="badge">PC Â· Tablet Â· Phone</div>
  </div>

  <div class="top">
    <div class="stat"><div class="lab">Episode</div><div class="val" id="epDisp">1</div></div>
    <div class="stat"><div class="lab">Map</div><div class="valSmall" id="mapName">-</div></div>
    <div class="stat"><div class="lab">Wave</div><div class="val" id="waveDisp">0</div></div>
    <div class="stat"><div class="lab">Life</div><div class="val" id="lifeDisp">20</div></div>
    <div class="stat"><div class="lab">Energy</div><div class="val" id="energyDisp">500</div></div>
    <div class="stat"><div class="lab">Enemy Core</div><div class="valSmall" id="coreDisp">-</div></div>
    <div class="stat"><div class="lab">Units / Enemies</div><div class="valSmall" id="countsDisp">-</div></div>
    <button class="btn" id="startWaveBtn">â–¶ ì›¨ì´ë¸Œ ì‹œì‘</button>
  </div>

  <div class="row">
    <div class="chip">ì—í”¼ì†Œë“œ/ë§µ:
      <select id="mapSelect"></select>
    </div>

    <button class="btn secondary" id="storyBtn">ğŸ“œ ìŠ¤í† ë¦¬</button>
    <button class="btn secondary" id="restartBtn">R ì¬ì‹œì‘</button>

    <button class="btnToggle on" id="modeTowerBtn">ğŸ› ï¸ ì„¤ì¹˜ ëª¨ë“œ</button>
    <button class="btnToggle" id="modeUnitBtn">ğŸš€ ì†Œí™˜ ëª¨ë“œ</button>

    <button class="btn good" id="spawnBtn">+ ì†Œí™˜(ë²„íŠ¼)</button>

    <div class="chip" id="selInfo">
      <span>íƒ€ì›Œ: <b id="selTowerName">-</b></span>
      <span>ìœ ë‹›: <b id="selUnitName">-</b></span>
    </div>
  </div>

  <canvas id="game"></canvas>

  <div class="bars">
    <div>
      <div class="barTitle">ğŸ›¡ï¸ íƒ€ì›Œ ì„ íƒ (ì„¤ì¹˜ ëª¨ë“œì—ì„œ íƒ­ / 1~9)</div>
      <div class="gridCards" id="towerBar"></div>
    </div>
    <div>
      <div class="barTitle">âš”ï¸ ìœ ë‹› ì„ íƒ (ì†Œí™˜ ëª¨ë“œì—ì„œ íƒ­ ë˜ëŠ” +ì†Œí™˜ / Z X C V B N M)</div>
      <div class="gridCards" id="unitBar"></div>
    </div>
  </div>

  <div class="bottom">
    <div class="pills">
      <div class="pill"><span class="kbd">ì„¤ì¹˜/ì†Œí™˜</span> ëª¨ë“œ ë²„íŠ¼ìœ¼ë¡œ ì „í™˜(ëª¨ë°”ì¼ ìµœì )</div>
      <div class="pill"><span class="kbd">+ì†Œí™˜</span> ì›¨ì´ë¸Œ ì¤‘ì—ë§Œ ê°€ëŠ¥(ê¸°ë³¸: ë‚´ ê¸°ì§€ ê·¼ì²˜)</div>
      <div class="pill"><span class="kbd">ë“œë˜ê·¸</span> í™”ë©´ ì´ë™(íŒ¨ë‹)</div>
      <div class="pill"><span class="kbd">íœ /í•€ì¹˜</span> í™•ëŒ€/ì¶•ì†Œ</div>
      <div class="pill"><span class="kbd">R</span> ì¬ì‹œì‘</div>
    </div>
    <div class="status" id="status"></div>
  </div>
</div>

<div class="modalBack" id="modalBack">
  <div class="modal">
    <h2 id="storyTitle">-</h2>
    <div class="sub" id="storySub">-</div>
    <div class="text" id="storyText"></div>
    <div class="row2">
      <span class="tag">ëª©í‘œ: <b id="storyGoal">-</b></span>
      <span class="miniHelp">Tip: ì›¨ì´ë¸Œ ì¤‘ +ì†Œí™˜ìœ¼ë¡œ ì‰½ê³  ë¹ ë¥´ê²Œ ëŸ¬ì‹œ</span>
      <button class="btn" id="closeStoryBtn">ê³„ì†</button>
    </div>
  </div>
</div>

<!-- Epilogue / Fade -->
<div id="fadeOverlay" style="position:fixed;inset:0;background:#000;opacity:0;pointer-events:none;transition:opacity .6s ease;z-index:80"></div>
<div class="modalBack" id="epilogueBack" style="z-index:90;">
  <div class="modal">
    <h2>ì‘ì „ ì¢…ë£Œ</h2>
    <div class="sub">ë‹¬ ì•ë©´ ì „ì—­ í™•ë³´ Â· ì œ4ì œêµ­ ì „ì§„ ì½”ì–´ ë¬´ë ¥í™”</div>
    <div class="text">ëª¨ë“  ì „ì—­ì„ í´ë¦¬ì–´í–ˆìŠµë‹ˆë‹¤.\n\në‹¬ ë’·ë©´ì€ ì§€í˜•ê³¼ í†µì‹  ìŒì˜, ê·¸ë¦¬ê³  ì”ì¡´ ë³‘ë ¥ì˜ ì €í•­ìœ¼ë¡œ ì¸í•´ \"ì ë ¹ ë¶ˆê°€ êµ¬ì—­\"ìœ¼ë¡œ ë‚¨ìŠµë‹ˆë‹¤.\ní•˜ì§€ë§Œ ì•ë©´ì˜ í•µì‹¬ ê±°ì ë“¤ì´ í™•ë³´ë˜ë©´ì„œ, ì§€êµ¬-ë‹¬ ë³´ê¸‰ë¡œëŠ” ë‹¤ì‹œ ì—´ë ¸ìŠµë‹ˆë‹¤.\n\nâ€” ì—í•„ë¡œê·¸ì—ì„œ ì „í›„ ìƒí™©ì„ í™•ì¸í•˜ì„¸ìš”.</div>
    <div class="row2">
      <span class="tag">ë‹¤ìŒ: <b>EPILOGUE</b></span>
      <span class="miniHelp">ë²„íŠ¼ì„ ëˆ„ë¥´ë©´ í™”ë©´ì´ ì–´ë‘ì›Œì§€ë©° ì´ë™í•©ë‹ˆë‹¤.</span>
      <button class="btn" id="epilogueBtn">ì—í•„ë¡œê·¸ ë³´ê¸°</button>
    </div>
  </div>
</div>

<script>
/* =========================================================
   StarShield2: Moonfront War (single file)
   - fetch(JSON)ë¡œ ë¡œë”© (blobURL)
   - ë§µ 18 (ì—í”¼ì†Œë“œ 6, ê° 3ë§µ)
   - ì  íƒ€ì›Œ: ì  ì½”ì–´ ê·¼ì²˜ë§Œ ì„¤ì¹˜ + ê³µê²©/ë°©ì–´ AI
   - ì•„êµ° ìœ ë‹›: ì  íƒ€ì›Œ/ì /ì½”ì–´ ê³µê²© ê°€ëŠ¥
   - ìœ ë‹› ì†Œí™˜: ì›¨ì´ë¸Œ ì¤‘ì—ë§Œ ê°€ëŠ¥ (+ì†Œí™˜ ë²„íŠ¼ / ì†Œí™˜ ëª¨ë“œ íƒ­)
   - íƒ€í‚¤ì˜¨ íƒ€ì›Œ(5000 ì—ë„ˆì§€) ì¶”ê°€
   - EP6 ë¸”ë™í™€ ê¶¤ë„ì „: í›„ë°˜ "Reich Carrier"ë§Œ ë‚˜ì˜¤ê²Œ
   ========================================================= */
function blobURL(obj){
  return URL.createObjectURL(new Blob([JSON.stringify(obj)], {type:"application/json"}));
}

/* ============ DATA (TOWERS / ENEMY TOWERS / UNITS / ENEMIES) ============ */
const EMBED_TOWERS = [
  { id:"laser",   name:"ë ˆì´ì € íƒ€ì›Œ", hotkey:"1", cost:60,  baseRange:170, fireRate:30, baseDamage:12, bulletSpeed:9.3, splashRadius:0,  slowFactor:1,   slowDuration:0,   mode:"bullet", poisonDps:0,    poisonDuration:0,    baseHp:80,  desc:"ê¸°ë³¸ DPS. ì´ˆë°˜ ì•ˆì •ì ." },
  { id:"rail",    name:"ë ˆì¼ê±´ íƒ€ì›Œ", hotkey:"2", cost:110, baseRange:285, fireRate:68, baseDamage:42, bulletSpeed:13.5, splashRadius:0,  slowFactor:1,   slowDuration:0,   mode:"bullet", poisonDps:0,    poisonDuration:0,    baseHp:105, desc:"ì´ˆì¥ê±°ë¦¬ ì €ê²©. ì—˜ë¦¬íŠ¸/ë³´ìŠ¤." },
  { id:"missile", name:"ë¯¸ì‚¬ì¼ íƒ€ì›Œ", hotkey:"3", cost:140, baseRange:195, fireRate:54, baseDamage:20, bulletSpeed:7.8, splashRadius:72, slowFactor:1,   slowDuration:0,   mode:"bullet", poisonDps:0,    poisonDuration:0,    baseHp:120, desc:"ë²”ìœ„ í­ë°œ. ë¬´ë¦¬ ì²˜ì¹˜." },
  { id:"slow",    name:"ìŠ¬ë¡œìš° íƒ€ì›Œ", hotkey:"4", cost:95,  baseRange:170, fireRate:58, baseDamage:6,  bulletSpeed:8.0, splashRadius:52, slowFactor:0.50,slowDuration:95,  mode:"bullet", poisonDps:0,    poisonDuration:0,    baseHp:105, desc:"ì´ë™ ì†ë„ í¬ê²Œ ê°ì†Œ." },
  { id:"pulse",   name:"í„ìŠ¤ íƒ€ì›Œ",   hotkey:"5", cost:165, baseRange:150, fireRate:70, baseDamage:26, bulletSpeed:0,   splashRadius:0,  slowFactor:1,   slowDuration:0,   mode:"pulse",  poisonDps:0,    poisonDuration:0,    baseHp:135, desc:"ê·¼ê±°ë¦¬ ê´‘ì—­ í„ìŠ¤." },
  { id:"poison",  name:"í¬ì´ì¦Œ íƒ€ì›Œ", hotkey:"6", cost:130, baseRange:175, fireRate:44, baseDamage:7,  bulletSpeed:8.7, splashRadius:0,  slowFactor:1,   slowDuration:0,   mode:"bullet", poisonDps:0.55, poisonDuration:150,  baseHp:95,  desc:"ë… ì§€ì† í”¼í•´(ì²´ë ¥ ë¹„ë¡€ì‹ ì•„ë‹˜)." },
  { id:"heal",    name:"ë¦¬í˜ì–´ íƒ€ì›Œ", hotkey:"7", cost:160, baseRange:140, fireRate:75, baseDamage:0,  bulletSpeed:0,   splashRadius:0,  slowFactor:1,   slowDuration:0,   mode:"heal",   poisonDps:0,    poisonDuration:0,    baseHp:105, healAmount:6, desc:"ì£¼ë³€ íƒ€ì›Œ ìˆ˜ë¦¬." },
  { id:"aa",      name:"AA ìŠ¤í”¼ì–´",   hotkey:"8", cost:190, baseRange:220, fireRate:40, baseDamage:18, bulletSpeed:15.5, splashRadius:0,  slowFactor:1,   slowDuration:0,   mode:"bullet", poisonDps:0,    poisonDuration:0,    baseHp:125, desc:"ë¹ ë¥¸ íƒ„ì†. ì›ê±°ë¦¬ ìœ ë‹›/ìŠ¤ì›œ." },
  { id:"tachyon", name:"íƒ€í‚¤ì˜¨ íƒ€ì›Œ", hotkey:"9", cost:5000,baseRange:520, fireRate:18, baseDamage:320,bulletSpeed:20.0, splashRadius:110,slowFactor:0.72,slowDuration:45,  mode:"bullet", poisonDps:0,    poisonDuration:0,    baseHp:260, desc:"5000âš¡. ëŒ€ë¶€ë¶„ ì  2ë°©ì»·ê¸‰(í›„ë°˜ìš©)." }
];

// ì  íƒ€ì›Œ(RED) - ì½”ì–´ ê·¼ì²˜ì—ë§Œ ë°°ì¹˜(ìë™/AI)
const EMBED_ENEMY_TOWERS = [
  { id:"r_laser",   name:"RED ë ˆì´ì € í¬ìŠ¤íŠ¸", cost:120, range:190, fireRate:38, damage:10, bulletSpeed:9.0, splashRadius:0,  hp:130, mode:"bullet" },
  { id:"r_mortar",  name:"RED ë°•ê²©í¬",        cost:170, range:240, fireRate:70, damage:16, bulletSpeed:7.0, splashRadius:90, hp:150, mode:"bullet" },
  { id:"r_sniper",  name:"RED ìŠ¤ë‚˜ì´í¼ ë¦´ë ˆì´",cost:220,range:320, fireRate:84, damage:26, bulletSpeed:14.0,splashRadius:0,  hp:120, mode:"bullet" },
  { id:"r_field",   name:"RED ê°ì†ì¥",        cost:200, range:200, fireRate:62, damage:5,  bulletSpeed:8.0, splashRadius:62, hp:160, mode:"bullet", slowFactor:0.55, slowDuration:90 },
  { id:"r_burst",   name:"RED ë²„ìŠ¤íŠ¸ ì½”ì¼",    cost:260, range:160, fireRate:75, damage:22, bulletSpeed:0,   splashRadius:0,  hp:175, mode:"pulse" }
];

const EMBED_ENEMIES = {
  normal:{ name:"Reich Drone",       color:"#ff62c9", hpFactor:1.00, speedBase:1.10, speedGrow:0.06, atkRange:140, atkRate:72, atkDamage:6 },
  fast:  { name:"Reich Striker",     color:"#6af7ff", hpFactor:0.85, speedBase:1.95, speedGrow:0.08, atkRange:140, atkRate:58, atkDamage:5 },
  tank:  { name:"Reich Juggernaut",  color:"#ffb347", hpFactor:2.60, speedBase:0.78, speedGrow:0.04, atkRange:155, atkRate:85, atkDamage:13 },
  swarm: { name:"Reich Swarm",       color:"#c6ff7a", hpFactor:0.60, speedBase:1.55, speedGrow:0.07, atkRange:110, atkRate:52, atkDamage:3 },
  shield:{ name:"Reich Shielded",    color:"#a38bff", hpFactor:1.80, speedBase:1.05, speedGrow:0.05, atkRange:150, atkRate:76, atkDamage:7 },
  regen: { name:"Reich Regenerator", color:"#7cf9c2", hpFactor:1.55, speedBase:1.05, speedGrow:0.05, atkRange:145, atkRate:70, atkDamage:6, regenFactor:0.03 },
  sniper:{ name:"Reich Sniper",      color:"#90caf9", hpFactor:0.78, speedBase:1.25, speedGrow:0.05, atkRange:270, atkRate:70, atkDamage:10 },
  bomber:{ name:"Reich Bomber",      color:"#ff867c", hpFactor:1.75, speedBase:1.00, speedGrow:0.05, atkRange:165, atkRate:74, atkDamage:11 },
  brute: { name:"Reich Brute",       color:"#ffab91", hpFactor:2.95, speedBase:0.92, speedGrow:0.05, atkRange:150, atkRate:78, atkDamage:14 },
  medic: { name:"Reich Medic",       color:"#80cbc4", hpFactor:1.45, speedBase:1.15, speedGrow:0.05, atkRange:140, atkRate:78, atkDamage:4,
           healRadius:170, healFactor:0.08, healInterval:45 },
  boss:  { name:"Reich Carrier",     color:"#ff3b6b", hpFactor:9.50, speedBase:0.62, speedGrow:0.05, atkRange:220, atkRate:62, atkDamage:18 }
};

const EMBED_UNITS = [
  { id:"fighter",  name:"íŒŒì´í„°(ê·¼ì ‘)",  hotkey:"Z", cost:55,  hp:90,  speed:1.95, range:34,  atkRate:24, damage:9,  mode:"melee",  coreStrikes:7, desc:"ëŒê²©. ì /ì íƒ€ì›Œì— ë¶™ì–´ì„œ ë‚œíƒ€." },
  { id:"rifle",    name:"ë¼ì´í”Œ(ì›ê±°ë¦¬)",hotkey:"X", cost:78,  hp:78,  speed:1.60, range:175, atkRate:30, damage:11, mode:"ranged", bulletSpeed:12.2, coreStrikes:6, desc:"ì•ˆì •ì  DPS. ì íƒ€ì›Œë„ ì œê±°." },
  { id:"sniperU",  name:"ìŠ¤ë‚˜ì´í¼",      hotkey:"C", cost:125, hp:62,  speed:1.40, range:310, atkRate:58, damage:30, mode:"ranged", bulletSpeed:15.2, coreStrikes:5, desc:"ì´ˆì¥ê±°ë¦¬. ì½”ì–´/ì íƒ€ì›Œì— ê°•í•¨." },
  { id:"bomberU",  name:"í­ê²©ë“œë¡ ",      hotkey:"V", cost:150, hp:92,  speed:1.35, range:190, atkRate:54, damage:15, mode:"splash", bulletSpeed:9.8, splashRadius:78, coreStrikes:6, desc:"ë²”ìœ„ í­ë°œ. ìŠ¤ì›œ/íƒ€ì›Œ ì£¼ë³€ ì²­ì†Œ." },
  { id:"medicU",   name:"ë©”ë”•(ì§€ì›)",    hotkey:"B", cost:110, hp:84,  speed:1.55, range:170, atkRate:50, damage:0,  mode:"heal", healAmount:7, coreStrikes:0, desc:"ì£¼ë³€ ì•„êµ° íšŒë³µ. ëŸ¬ì‹œ ìœ ì§€." },
  { id:"guardian", name:"ê°€ë””ì–¸(íƒ±ì»¤)",  hotkey:"N", cost:210, hp:260, speed:1.05, range:60,  atkRate:36, damage:12, mode:"melee", coreStrikes:8, desc:"ë‘êº¼ìš´ ì „ì—´. ì  íƒ€ì›Œ ì–´ê·¸ë¡œ." },
  { id:"emp",      name:"EMP í•´ì»¤",      hotkey:"M", cost:230, hp:90,  speed:1.35, range:220, atkRate:66, damage:9,  mode:"emp", bulletSpeed:11.0, empSlow:0.55, empDur:85, coreStrikes:4, desc:"ë§ì¶˜ ì /ì íƒ€ì›Œë¥¼ ë‘”í™”+ê³µê²©ì†ë„ ì €í•˜." }
];

/* ============ EPISODES / MAPS (6 episodes Ã— 3 maps = 18) ============ */
const EPISODES = [
  {
    id:"ep1", title:"EP1 â€” ì˜¤ì„¸ì•„ëˆ„ìŠ¤ í”„ë¡œì¼ˆë¼ë£¸: ìƒë¥™ êµë‘ë³´",
    location:"Moon Nearside Â· Oceanus Procellarum",
    brief:
`ì œ4ì œêµ­(NAZI)ì€ ë‹¬ ì•ë©´ì˜ ìš©ì•”í‰ì›ì— ë¹„ë°€ ê¸°ì§€ë¥¼ êµ¬ì¶•í•˜ê³ , ì§€êµ¬-ë‹¬ ë³´ê¸‰ë¡œë¥¼ ìœ„í˜‘í•œë‹¤.
ë¯¸í•©ì¤‘êµ­ ë‹¬ì›ì •êµ°ì€ ì•„í´ë¡œ êµ¬ì—­ì˜ ì”í•´ë¥¼ íšŒìˆ˜í•´ â€˜ììœ ì˜ êµë‘ë³´â€™ë¥¼ ì„¸ì›Œì•¼ í•œë‹¤.
ëª©í‘œ: í”„ë¡œì¼ˆë¼ë£¸ í•´ì˜ ê´€ë¬¸ì„ ì—´ê³ , ì ì˜ ì „ì§„ ì½”ì–´ë¥¼ íŒŒê´´í•˜ë¼.` ,
    maps:["europa_rift_A","europa_rift_B","europa_rift_C"]
  },
  {
    id:"ep2", title:"EP2 â€” ì½”í˜ë¥´ë‹ˆì¿ ìŠ¤ ê³ ì›: í¬ê²©ë§ ëŒíŒŒ",
    location:"Moon Nearside Â· Copernicus Highlands",
    brief:
`ì½”í˜ë¥´ë‹ˆì¿ ìŠ¤ ë¶„í™”êµ¬ ê³ ì›ì€ â€˜ê´‘í•™ ì‚¬ê²© í†µì œâ€™ì˜ ìš”ì§€.
ì œ4ì œêµ­ì€ ë°˜ì‚¬ê²½ê³¼ ë ˆì´ë”ë¥¼ ì—°ê²°í•´ ë‹¬ ì•ë©´ ì „ì—­ì„ í¬ê²©ê¶Œì— ë„£ì—ˆë‹¤.
ê³ ì› ë°©ì–´ì§„ì„ ë¶•ê´´ì‹œí‚¤ê³ , í†µì œ ë…¸ë“œë¥¼ ëŠì–´ë¼.` ,
    maps:["mars_yard_A","mars_yard_B","mars_yard_C"]
  },
  {
    id:"ep3", title:"EP3 â€” ë§ˆë ˆ ì„ë¸Œë¦¬ì›€: ê¶¤ë„ì—ì„œ ìŸì•„ì§€ëŠ” ì² ",
    location:"Moon Nearside Â· Mare Imbrium",
    brief:
`ë§ˆë ˆ ì„ë¸Œë¦¬ì›€(ë¹„ì˜ ë°”ë‹¤)ì—ëŠ” ëŒ€í˜• ë¬¼ì ì ì¹˜ì¥ê³¼ ì´ë™ì‹ ë ˆì¼ ìºí„°í„íŠ¸ê°€ ìˆë‹¤.
ì—¬ê¸°ì„œ ì˜ì•„ ì˜¬ë¦° ë³´ê¸‰ì´ ì œ4ì œêµ­ ì „ì„ ì˜ í˜ˆê´€ì´ ëœë‹¤.
í‰ì›ì„ ê°€ë¡œì§€ë¥´ëŠ” ê¸´ ë³´ê¸‰ë¡œë¥¼ ëŠê³ , ì ì˜ í•­ëª¨ê¸‰ ë“œë¡  íˆ¬ì…ì„ ë§‰ì•„ë¼.` ,
    maps:["titan_flats_A","titan_flats_B","titan_flats_C"]
  },
  {
    id:"ep4", title:"EP4 â€” íŠ¸ë‘í€¼ë¦¬íƒ€í‹°ìŠ¤: ì°©ë¥™ì§€ ì‚¬ìˆ˜",
    location:"Moon Nearside Â· Mare Tranquillitatis",
    brief:
`ê³ ìš”ì˜ ë°”ë‹¤(ë§ˆë ˆ íŠ¸ë‘í€¼ë¦¬íƒ€í‹°ìŠ¤)ëŠ” ì¸ë¥˜ ìµœì´ˆ ì°©ë¥™ì§€ì´ì ìƒì§•.
ì œ4ì œêµ­ì€ ì´ê³³ì„ ì ë ¹í•´ â€˜ì„ ì „ì˜ ê¹ƒë°œâ€™ì„ ê½‚ìœ¼ë ¤ í•œë‹¤.
ìœ ì  êµ¬ì—­ì„ ë³´ì¡´í•˜ë©´ì„œë„ ë°©ì–´ì„ ì„ êµ¬ì¶•í•´, ì ì˜ ì¥ê±°ë¦¬ ì €ê²©ì„ ë²„í…¨ë¼.` ,
    maps:["kuiper_relay_A","kuiper_relay_B","kuiper_relay_C"]
  },
  {
    id:"ep5", title:"EP5 â€” ì„¸ë ˆë‹ˆíƒ€í‹°ìŠ¤Â·í”Œë¼í† : ë¶„í™”êµ¬ ì‚¬ìŠ¬ì „",
    location:"Moon Nearside Â· Mare Serenitatis & Plato",
    brief:
`ë§‘ìŒì˜ ë°”ë‹¤(ì„¸ë ˆë‹ˆíƒ€í‹°ìŠ¤) ë¶ë‹¨ê³¼ í”Œë¼í†  ë¶„í™”êµ¬ ì¼ëŒ€ëŠ” ì²œì—° ì„±ë²½.
ì œ4ì œêµ­ì€ ë¶„í™”êµ¬ ë¦¼ì— ë°©ì–´íƒ€ì›Œë¥¼ ì¦ì‹ì‹œì¼œ â€˜ì¥ê¸° ì ë ¹â€™ì„ ë…¸ë¦°ë‹¤.
ì•„êµ°ì€ ìœ ë‹› ëŸ¬ì‹œë¡œ íƒ€ì›Œë¥¼ ì •ë¦¬í•˜ê³ , ì „ì„ ì„ ì „ì§„ì‹œì¼œë¼.` ,
    maps:["nebula_mine_A","nebula_mine_B","nebula_mine_C"]
  },
  {
    id:"ep6", title:"EP6 â€” í‹°ì½”Â·ì•„ë¦¬ìŠ¤íƒ€ë¥´ì½”ìŠ¤: ë‹¬ ì•ë©´ ìµœì¢… ê²°ì „",
    location:"Moon Nearside Â· Tycho & Aristarchus",
    brief:
`í‹°ì½”ì˜ ë°©ì‚¬ìƒ ì§€í˜•ê³¼ ì•„ë¦¬ìŠ¤íƒ€ë¥´ì½”ìŠ¤ ê³ ì›ì€ ë‹¬ ì•ë©´ì˜ ë§ˆì§€ë§‰ ìš”ìƒˆ.
ì œ4ì œêµ­ì€ â€˜ì•ë©´ ì™„ì „ ì ë ¹â€™ì„ ì„ ì–¸í•˜ì§€ë§Œ, ë‹¬ ë’·ë©´ì€ ì €í•­ì´ ê·¹ì‹¬í•´ ëë‚´ ì¥ì•…í•˜ì§€ ëª»í–ˆë‹¤.
ì´ì œ ë‚¨ì€ ê±´ ì•ë©´ì˜ ì¤‘ì•™ ì½”ì–´.
í›„ë°˜ë¶€ì—ëŠ” í•­ëª¨ê¸‰ â€˜Reich Carrierâ€™ë§Œì´ ì—°ì† íˆ¬ì…ëœë‹¤. ëª¨ë“  ê²ƒì„ ëë‚´ë¼.` ,
    maps:["blackhole_orbit_A","blackhole_orbit_B","blackhole_orbit_C"]
  }
];
const MAPS = [
  // EP1
  { id:"europa_rift_A", ep:0, name:"Procellarum â€” Landing Lane", tileSize:42, cols:36, rows:20, difficulty:1.00, initialEnergy:560, clearWaves:6,
    pathTiles:[[0,10],[5,10],[5,4],[12,4],[12,16],[20,16],[20,6],[28,6],[28,14],[35,14]],
    enemyTowerMax:6, enemyTowerRadiusTiles:7
  },
  { id:"europa_rift_B", ep:0, name:"Procellarum â€” Survey Ridges", tileSize:42, cols:38, rows:20, difficulty:1.06, initialEnergy:580, clearWaves:7,
    pathTiles:[[0,8],[10,8],[10,3],[18,3],[18,12],[26,12],[26,6],[33,6],[33,18],[37,18]],
    enemyTowerMax:7, enemyTowerRadiusTiles:8
  },
  { id:"europa_rift_C", ep:0, name:"Procellarum â€” Crater Switchbacks", tileSize:41, cols:40, rows:22, difficulty:1.12, initialEnergy:610, clearWaves:8,
    pathTiles:[[0,12],[8,12],[8,5],[16,5],[16,18],[24,18],[24,8],[32,8],[32,20],[39,20]],
    enemyTowerMax:8, enemyTowerRadiusTiles:8
  },

  // EP2
  { id:"mars_yard_A", ep:1, name:"Copernicus â€” Outer Ramparts", tileSize:40, cols:40, rows:22, difficulty:1.18, initialEnergy:640, clearWaves:8,
    pathTiles:[[0,11],[9,11],[9,4],[17,4],[17,17],[25,17],[25,6],[33,6],[33,20],[39,20]],
    enemyTowerMax:9, enemyTowerRadiusTiles:9
  },
  { id:"mars_yard_B", ep:1, name:"Copernicus â€” Ridge Zigzag", tileSize:40, cols:42, rows:22, difficulty:1.25, initialEnergy:670, clearWaves:9,
    pathTiles:[[0,9],[12,9],[12,3],[22,3],[22,18],[10,18],[10,12],[30,12],[30,20],[41,20]],
    enemyTowerMax:10, enemyTowerRadiusTiles:9
  },
  { id:"mars_yard_C", ep:1, name:"Copernicus â€” Highland Corridor", tileSize:39, cols:44, rows:22, difficulty:1.33, initialEnergy:700, clearWaves:10,
    pathTiles:[[0,10],[14,10],[14,5],[26,5],[26,16],[18,16],[18,8],[36,8],[36,20],[43,20]],
    enemyTowerMax:11, enemyTowerRadiusTiles:10
  },

  // EP3
  { id:"titan_flats_A", ep:2, name:"Imbrium â€” Supply Flats", tileSize:38, cols:46, rows:24, difficulty:1.42, initialEnergy:730, clearWaves:10,
    pathTiles:[[0,12],[10,12],[10,4],[24,4],[24,20],[12,20],[12,10],[34,10],[34,22],[45,22]],
    enemyTowerMax:12, enemyTowerRadiusTiles:10
  },
  { id:"titan_flats_B", ep:2, name:"Imbrium â€” Rail Traverse", tileSize:38, cols:48, rows:24, difficulty:1.50, initialEnergy:760, clearWaves:11,
    pathTiles:[[0,8],[16,8],[16,3],[30,3],[30,18],[8,18],[8,13],[38,13],[38,22],[47,22]],
    enemyTowerMax:13, enemyTowerRadiusTiles:10
  },
  { id:"titan_flats_C", ep:2, name:"Imbrium â€” Triple Bend", tileSize:37, cols:50, rows:26, difficulty:1.58, initialEnergy:800, clearWaves:12,
    pathTiles:[[0,13],[12,13],[12,5],[26,5],[26,22],[16,22],[16,11],[38,11],[38,24],[49,24]],
    enemyTowerMax:14, enemyTowerRadiusTiles:11
  },

  // EP4
  { id:"kuiper_relay_A", ep:3, name:"Tranquillitatis â€” Heritage Line", tileSize:36, cols:54, rows:26, difficulty:1.70, initialEnergy:840, clearWaves:12,
    pathTiles:[[0,12],[16,12],[16,6],[32,6],[32,20],[20,20],[20,10],[44,10],[44,24],[53,24]],
    enemyTowerMax:15, enemyTowerRadiusTiles:11
  },
  { id:"kuiper_relay_B", ep:3, name:"Tranquillitatis â€” Broken Channel", tileSize:36, cols:56, rows:26, difficulty:1.78, initialEnergy:880, clearWaves:13,
    pathTiles:[[0,10],[18,10],[18,4],[36,4],[36,22],[12,22],[12,14],[46,14],[46,24],[55,24]],
    enemyTowerMax:16, enemyTowerRadiusTiles:12
  },
  { id:"kuiper_relay_C", ep:3, name:"Tranquillitatis â€” Sniper Lane", tileSize:35, cols:58, rows:28, difficulty:1.86, initialEnergy:920, clearWaves:14,
    pathTiles:[[0,13],[20,13],[20,5],[40,5],[40,23],[18,23],[18,11],[50,11],[50,26],[57,26]],
    enemyTowerMax:17, enemyTowerRadiusTiles:12
  },

  // EP5
  { id:"nebula_mine_A", ep:4, name:"Serenitatis â€” Rim Roads", tileSize:35, cols:60, rows:28, difficulty:1.98, initialEnergy:980, clearWaves:14,
    pathTiles:[[0,10],[20,10],[20,4],[44,4],[44,20],[24,20],[24,14],[52,14],[52,26],[59,26]],
    enemyTowerMax:18, enemyTowerRadiusTiles:12
  },
  { id:"nebula_mine_B", ep:4, name:"Plato â€” Ore Zigzag", tileSize:34, cols:62, rows:30, difficulty:2.10, initialEnergy:1040, clearWaves:15,
    pathTiles:[[0,14],[22,14],[22,5],[46,5],[46,24],[16,24],[16,12],[54,12],[54,28],[61,28]],
    enemyTowerMax:20, enemyTowerRadiusTiles:13
  },
  { id:"nebula_mine_C", ep:4, name:"Serenitatis â€” Core Trench", tileSize:34, cols:64, rows:30, difficulty:2.22, initialEnergy:1120, clearWaves:16,
    pathTiles:[[0,11],[24,11],[24,4],[50,4],[50,22],[28,22],[28,12],[58,12],[58,28],[63,28]],
    enemyTowerMax:22, enemyTowerRadiusTiles:13
  },

  // EP6
  { id:"blackhole_orbit_A", ep:5, name:"Tycho â€” Rayline Break", tileSize:34, cols:66, rows:30, difficulty:2.40, initialEnergy:1300, clearWaves:16,
    pathTiles:[[0,15],[26,15],[26,6],[52,6],[52,24],[18,24],[18,12],[60,12],[60,28],[65,28]],
    enemyTowerMax:22, enemyTowerRadiusTiles:13,
    special:{ bossOnlyAfterWave: 10, bossOnlyScale: 1.15 }
  },
  { id:"blackhole_orbit_B", ep:5, name:"Aristarchus â€” Plateau Ring", tileSize:33, cols:68, rows:32, difficulty:2.55, initialEnergy:1500, clearWaves:17,
    pathTiles:[[0,12],[28,12],[28,5],[56,5],[56,26],[16,26],[16,14],[62,14],[62,30],[67,30]],
    enemyTowerMax:24, enemyTowerRadiusTiles:14,
    special:{ bossOnlyAfterWave: 9, bossOnlyScale: 1.22 }
  },
  { id:"blackhole_orbit_C", ep:5, name:"Tycho â€” Final Run", tileSize:33, cols:70, rows:32, difficulty:2.75, initialEnergy:1700, clearWaves:18,
    pathTiles:[[0,16],[30,16],[30,6],[58,6],[58,26],[22,26],[22,12],[64,12],[64,30],[69,30]],
    enemyTowerMax:26, enemyTowerRadiusTiles:14,
    special:{ bossOnlyAfterWave: 8, bossOnlyScale: 1.30 }
  }
];

const URLS = {
  towers: blobURL(EMBED_TOWERS),
  enemyTowers: blobURL(EMBED_ENEMY_TOWERS),
  enemies: blobURL(EMBED_ENEMIES),
  units: blobURL(EMBED_UNITS),
  episodes: blobURL(EPISODES),
  maps: blobURL(MAPS)
};

/* =========================== GAME CORE =========================== */
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d", {alpha:true});

let CW=1280, CH=720, DPR=1;

const elEp = document.getElementById("epDisp");
const elMapName = document.getElementById("mapName");
const elWave = document.getElementById("waveDisp");
const elLife = document.getElementById("lifeDisp");
const elEnergy = document.getElementById("energyDisp");
const elCore = document.getElementById("coreDisp");
const elCounts = document.getElementById("countsDisp");
const elStatus = document.getElementById("status");
const elSelTowerName = document.getElementById("selTowerName");
const elSelUnitName  = document.getElementById("selUnitName");

const towerBar = document.getElementById("towerBar");
const unitBar = document.getElementById("unitBar");
const mapSelect = document.getElementById("mapSelect");
const startWaveBtn = document.getElementById("startWaveBtn");
const restartBtn = document.getElementById("restartBtn");
const storyBtn = document.getElementById("storyBtn");
const spawnBtn = document.getElementById("spawnBtn");
const modeTowerBtn = document.getElementById("modeTowerBtn");
const modeUnitBtn = document.getElementById("modeUnitBtn");

const modalBack = document.getElementById("modalBack");
const storyTitle = document.getElementById("storyTitle");
const storySub = document.getElementById("storySub");
const storyText = document.getElementById("storyText");
const storyGoal = document.getElementById("storyGoal");
const closeStoryBtn = document.getElementById("closeStoryBtn");

const epilogueBack = document.getElementById("epilogueBack");
const epilogueBtn  = document.getElementById("epilogueBtn");

const STORAGE_KEY = "starshield2_planetwars_progress";

/* loaded */
let towerTypes=[], enemyTowerTypes=[], enemyConfigs={}, unitTypes=[], episodes=[], maps=[];

let currentEp=0;
let currentMapId=null;
let currentMap=null;
let currentMapIndexInEpisode=0;

let TILE=40, COLS=0, ROWS=0;
let view={scale:1, ox:0, oy:0}; // world->screen

let grid=[];
let pathTiles=[];
let pathPoints=[];

let stars=[];
let tick=0;

let wave=0;
let lives=20;
let energy=500;

let waveInProgress=false;
let spawnQueue=[];
let gameOver=false;
let victory=false;

/* entities */
let enemyId=1, allyId=1, towerId=1, enemyTowerId=1;
let enemies=[], allies=[], towers=[], enemyTowers=[];
let bullets=[], allyBullets=[], enemyBullets=[], enemyTowerBullets=[];
let pulses=[];

let selectedTowerIndex=0;
let selectedUnitIndex=0;

let mode="tower"; // "tower" or "unit" (ëª¨ë°”ì¼ì—ì„œ í™•ì‹¤íˆ)
let mouse={tx:-1, ty:-1, ok:false, kind:"tower"};

let enemyCore=null;
let playerCore=null;

/* enemy build AI */
let redEnergy=0;
let redBuildCooldown=0;

/* utils */
function clamp(v,a,b){return Math.max(a,Math.min(b,v));}
function dist(a,b){const dx=a.x-b.x, dy=a.y-b.y; return Math.sqrt(dx*dx+dy*dy);}
function tileCenter(tx,ty){return {x:tx*TILE+TILE/2, y:ty*TILE+TILE/2};}
function worldW(){return COLS*TILE;}
function worldH(){return ROWS*TILE;}

function setStatus(msg, tone="good"){
  elStatus.textContent = msg;
  elStatus.classList.remove("goodText","badText","warnText");
  if(tone==="good") elStatus.classList.add("goodText");
  else if(tone==="bad") elStatus.classList.add("badText");
  else elStatus.classList.add("warnText");
}

/* responsive canvas */
function resizeCanvas(){
  const rect = canvas.getBoundingClientRect();
  DPR = Math.max(1, window.devicePixelRatio || 1);
  CW = Math.max(640, Math.floor(rect.width * DPR));
  CH = Math.max(420, Math.floor(rect.height * DPR));
  canvas.width = CW;
  canvas.height = CH;
  recalcFit();
  clampCamera();
}
window.addEventListener("resize", resizeCanvas, {passive:true});

/* progress */
function defaultProgress(){
  return { unlockedEpisode:0, unlockedMapByEpisode:{ "0":0 }, seenCutscene:{} };
}
function loadProgress(){
  try{
    const raw=localStorage.getItem(STORAGE_KEY);
    if(!raw) return defaultProgress();
    const p=JSON.parse(raw);
    if(typeof p.unlockedEpisode!=="number") p.unlockedEpisode=0;
    if(!p.unlockedMapByEpisode) p.unlockedMapByEpisode={"0":0};
    if(!p.seenCutscene) p.seenCutscene={};
    return p;
  }catch{
    return defaultProgress();
  }
}
function saveProgress(p){ localStorage.setItem(STORAGE_KEY, JSON.stringify(p)); }

/* camera */
function recalcFit(){
  if(COLS<=0||ROWS<=0) return;
  const ww=worldW(), hh=worldH();
  const s=Math.min(CW/ww, CH/hh);
  view.scale = clamp(s, 0.25, 1.10);
  view.ox = (CW - ww*view.scale)/2;
  view.oy = (CH - hh*view.scale)/2;
}
function clampCamera(){
  const ww = worldW()*view.scale;
  const hh = worldH()*view.scale;
  const margin=50;
  const minOx = CW - ww - margin;
  const maxOx = margin;
  const minOy = CH - hh - margin;
  const maxOy = margin;
  view.ox = clamp(view.ox, Math.min(minOx,maxOx), Math.max(minOx,maxOx));
  view.oy = clamp(view.oy, Math.min(minOy,maxOy), Math.max(minOy,maxOy));
}
function setWorldTransform(){ ctx.setTransform(view.scale,0,0,view.scale,view.ox,view.oy); }
function resetTransform(){ ctx.setTransform(1,0,0,1,0,0); }

function clientToCanvas(clientX, clientY){
  const r = canvas.getBoundingClientRect();
  const sx = (clientX - r.left) * (CW / r.width);
  const sy = (clientY - r.top) * (CH / r.height);
  return {sx, sy};
}
function screenToWorld(sx,sy){ return {x:(sx-view.ox)/view.scale, y:(sy-view.oy)/view.scale}; }

/* stars */
function initStars(){
  stars=[];
  for(let i=0;i<220;i++){
    stars.push({x:Math.random()*CW,y:Math.random()*CH,r:Math.random()*1.8+0.2,t:Math.random()*0.9+0.3});
  }
}

/* map grid helpers */
function isInside(tx,ty){ return tx>=0 && ty>=0 && tx<COLS && ty<ROWS; }

function findNearestValidTowerTile(tx,ty,maxR=3){
  for(let r=0;r<=maxR;r++){
    for(let dy=-r; dy<=r; dy++){
      for(let dx=-r; dx<=r; dx++){
        if(Math.abs(dx)!==r && Math.abs(dy)!==r) continue;
        const x=tx+dx, y=ty+dy;
        if(!isInside(x,y)) continue;
        const c=grid[y][x];
        if(!c.isPath && !c.hasTower && !c.hasEnemyTower) return {tx:x, ty:y};
      }
    }
  }
  return null;
}
function findNearestPathIndex(tx,ty,maxR=4){
  for(let r=0;r<=maxR;r++){
    for(let dy=-r; dy<=r; dy++){
      for(let dx=-r; dx<=r; dx++){
        if(Math.abs(dx)!==r && Math.abs(dy)!==r) continue;
        const x=tx+dx, y=ty+dy;
        if(!isInside(x,y)) continue;
        if(grid[y][x].isPath){
          const idx = pathTiles.findIndex(p=>p.x===x && p.y===y);
          if(idx>=0) return idx;
        }
      }
    }
  }
  return -1;
}

/* UI */
function refreshUI(){
  elEp.textContent = String(currentEp+1);
  elMapName.textContent = currentMap ? currentMap.name : "-";
  elWave.textContent = String(wave);
  elLife.textContent = String(lives);
  elEnergy.textContent = String(Math.floor(energy));
  elCore.textContent = enemyCore ? `${Math.max(0,Math.floor(enemyCore.hp))} / ${enemyCore.maxHp}` : "-";
  elCounts.textContent = `ì•„êµ° ${allies.length} | ì  ${enemies.length} | ì íƒ€ì›Œ ${enemyTowers.length}`;
  elSelTowerName.textContent = towerTypes[selectedTowerIndex]?.name ?? "-";
  elSelUnitName.textContent  = unitTypes[selectedUnitIndex]?.name ?? "-";

  startWaveBtn.textContent = waveInProgress ? "â³ ì›¨ì´ë¸Œ ì§„í–‰ ì¤‘" : "â–¶ ì›¨ì´ë¸Œ ì‹œì‘";
  startWaveBtn.style.opacity = waveInProgress ? 0.75 : 1.0;
  startWaveBtn.style.cursor = waveInProgress ? "not-allowed" : "pointer";

  spawnBtn.style.opacity = waveInProgress ? 1.0 : 0.55;
}

function buildTowerBar(){
  towerBar.innerHTML="";
  towerTypes.forEach((t,idx)=>{
    const d=document.createElement("div");
    d.className="card"+(idx===selectedTowerIndex?" sel":"");
    d.innerHTML=`
      <div class="cardTop">
        <div class="name">${t.name}</div>
        <div class="key">${t.hotkey || (idx+1)}</div>
      </div>
      <div class="cost">ë¹„ìš©: ${t.cost} âš¡</div>
      <div class="desc">${t.desc||""}</div>
    `;
    d.addEventListener("click", ()=>{
      selectedTowerIndex=idx;
      buildTowerBar();
      refreshUI();
      setStatus(`íƒ€ì›Œ ì„ íƒ: ${t.name}`, "good");
    });
    towerBar.appendChild(d);
  });
}
function buildUnitBar(){
  unitBar.innerHTML="";
  unitTypes.forEach((u,idx)=>{
    const d=document.createElement("div");
    d.className="card"+(idx===selectedUnitIndex?" sel":"");
    d.innerHTML=`
      <div class="cardTop">
        <div class="name">${u.name}</div>
        <div class="key">${u.hotkey}</div>
      </div>
      <div class="cost">ì†Œí™˜: ${u.cost} âš¡</div>
      <div class="desc">${u.desc||""}</div>
    `;
    d.addEventListener("click", ()=>{
      selectedUnitIndex=idx;
      buildUnitBar();
      refreshUI();
      setStatus(`ìœ ë‹› ì„ íƒ: ${u.name}`, "good");
    });
    unitBar.appendChild(d);
  });
}

function rebuildMapSelect(){
  const prog = loadProgress();
  mapSelect.innerHTML="";

  // flatten episode maps into one select, lock by (episode, mapIndex)
  episodes.forEach((ep, eidx)=>{
    const unlockedEp = prog.unlockedEpisode ?? 0;
    const unlockedMap = (prog.unlockedMapByEpisode?.[String(eidx)] ?? 0);

    ep.maps.forEach((mid, midx)=>{
      const mp = maps.find(m=>m.id===mid);
      const opt=document.createElement("option");
      opt.value = `${eidx}:${midx}`;
      const locked = (eidx>unlockedEp) || (eidx===unlockedEp && midx>unlockedMap);
      opt.disabled = locked;
      opt.textContent = locked
        ? `ğŸ”’ EP${eidx+1}-${midx+1} Â· ${mp?.name || mid}`
        : `EP${eidx+1}-${midx+1} Â· ${mp?.name || mid}`;
      mapSelect.appendChild(opt);
    });
  });

  mapSelect.value = `${currentEp}:${currentMapIndexInEpisode}`;
}

/* story modal */
function showStory(epIndex){
  const ep=episodes[epIndex];
  if(!ep) return;
  storyTitle.textContent = ep.title;
  const mp = maps.find(m=>m.id===currentMapId);
  storySub.textContent = `Location: ${ep.location} Â· Current Map: ${mp?.name || currentMapId}`;
  storyText.textContent = ep.brief + `\n\n[ì§„ì˜ ê·œì¹™]\n- ì œ4ì œêµ­ì€ ì  ì½”ì–´ ê·¼ì²˜ì— ìë™ìœ¼ë¡œ ë°©ì–´íƒ€ì›Œë¥¼ ê±´ì„¤í•©ë‹ˆë‹¤.\n- ì›¨ì´ë¸Œ ì¤‘ +ì†Œí™˜(ë²„íŠ¼)ìœ¼ë¡œ ìœ ë‹› ëŸ¬ì‹œê°€ í•µì‹¬ì…ë‹ˆë‹¤.\n- ìœ ë‹›ì€ ì  íƒ€ì›Œ/ì /ì½”ì–´ë¥¼ ê³µê²©í•©ë‹ˆë‹¤.`;
  const goal = currentMap?.clearWaves ?? 6;
  storyGoal.textContent = `ì´ ë§µ: ì›¨ì´ë¸Œ ${goal} í´ë¦¬ì–´ ë˜ëŠ” ì  ì½”ì–´ íŒŒê´´`;
  modalBack.style.display="flex";
}
function hideStory(){ modalBack.style.display="none"; }

/* map init */
function initMapByEpAndIndex(epIndex, mapIndex, showCutscene=true){
  const prog = loadProgress();
  const unlockedEp = prog.unlockedEpisode ?? 0;
  const unlockedMap = (prog.unlockedMapByEpisode?.[String(epIndex)] ?? 0);

  if(epIndex>unlockedEp || (epIndex===unlockedEp && mapIndex>unlockedMap)){
    setStatus("ì•„ì§ ì ê¸´ ë§µì…ë‹ˆë‹¤. ì´ì „ ë§µì„ í´ë¦¬ì–´í•˜ì„¸ìš”.", "bad");
    rebuildMapSelect();
    return;
  }

  currentEp=epIndex;
  currentMapIndexInEpisode=mapIndex;
  currentMapId = episodes[epIndex].maps[mapIndex];

  const map = maps.find(m=>m.id===currentMapId) || maps[0];
  currentMap = JSON.parse(JSON.stringify(map));

  TILE = currentMap.tileSize ?? 40;
  COLS = currentMap.cols;
  ROWS = currentMap.rows;

  grid = Array.from({length:ROWS},()=>Array.from({length:COLS},()=>({isPath:false,hasTower:false,hasEnemyTower:false})));

  pathTiles = currentMap.pathTiles.map(p=>({x:p[0],y:p[1]}));
  for(const t of pathTiles){ if(isInside(t.x,t.y)) grid[t.y][t.x].isPath=true; }
  pathPoints = pathTiles.map(t=>tileCenter(t.x,t.y));

  // cores
  const start = pathPoints[0];                         // enemy side
  const end = pathPoints[pathPoints.length-1];         // player side
  const diff = currentMap.difficulty ?? 1.0;

  enemyCore = {
    x:start.x, y:start.y,
    maxHp: Math.floor(1150*diff + (currentMap.clearWaves*190)),
    hp:    Math.floor(1150*diff + (currentMap.clearWaves*190))
  };
  playerCore = {x:end.x, y:end.y};

  // reset state
  resetGameStateOnly();

  // initial red defense
  redEnergy = 350 + Math.floor(200*diff);
  placeInitialEnemyTowers();

  recalcFit();
  clampCamera();
  resizeCanvas(); // ensure correct after DOM paint

  refreshUI();
  rebuildMapSelect();
  setStatus(`EP${currentEp+1}-${currentMapIndexInEpisode+1} ì‹œì‘: ${currentMap.name}`, "good");

  // cutscene once per episode
  if(showCutscene){
    const key = episodes[currentEp].id;
    if(!prog.seenCutscene[key]){
      showStory(currentEp);
      prog.seenCutscene[key]=true;
      saveProgress(prog);
    }
  }
}

function resetGameStateOnly(){
  enemies=[]; allies=[]; towers=[]; enemyTowers=[];
  bullets=[]; allyBullets=[]; enemyBullets=[]; enemyTowerBullets=[];
  pulses=[];
  wave=0; lives=20;
  energy = currentMap?.initialEnergy ?? 600;
  waveInProgress=false; spawnQueue=[];
  gameOver=false; victory=false;

  enemyId=1; allyId=1; towerId=1; enemyTowerId=1;
  tick=0;

  redBuildCooldown=0;

  for(let y=0;y<ROWS;y++){
    for(let x=0;x<COLS;x++){
      grid[y][x].hasTower=false;
      grid[y][x].hasEnemyTower=false;
    }
  }
  if(enemyCore) enemyCore.hp=enemyCore.maxHp;
}

/* Enemy tower placement near core */
function tileDistToCore(tx,ty){
  const c=tileCenter(tx,ty);
  return dist(c, enemyCore);
}
function canPlaceEnemyTower(tx,ty){
  if(!isInside(tx,ty)) return false;
  const cell=grid[ty][tx];
  if(cell.isPath || cell.hasTower || cell.hasEnemyTower) return false;
  const maxTiles = currentMap.enemyTowerRadiusTiles ?? 10;
  const maxDist = maxTiles*TILE;
  return tileDistToCore(tx,ty) <= maxDist;
}
function placeEnemyTower(tx,ty, typeId){
  const type = enemyTowerTypes.find(t=>t.id===typeId) || enemyTowerTypes[0];
  if(!type) return false;
  if(!canPlaceEnemyTower(tx,ty)) return false;

  const c=tileCenter(tx,ty);
  enemyTowers.push({
    id: enemyTowerId++,
    typeId: type.id,
    x:c.x, y:c.y,
    range:type.range,
    fireRate:type.fireRate,
    cooldown:Math.floor(type.fireRate*0.5),
    damage:type.damage,
    bulletSpeed:type.bulletSpeed,
    splashRadius:type.splashRadius,
    mode:type.mode,
    hp:type.hp,
    maxHp:type.hp,
    slowFactor:type.slowFactor||1,
    slowDuration:type.slowDuration||0,
    spin:Math.random()*Math.PI*2
  });
  grid[ty][tx].hasEnemyTower=true;
  return true;
}
function placeInitialEnemyTowers(){
  const maxInit = Math.min(4 + Math.floor((currentMap.difficulty||1)*2), currentMap.enemyTowerMax||10);
  let tries=0, placed=0;
  while(placed<maxInit && tries<1200){
    tries++;
    const maxTiles = currentMap.enemyTowerRadiusTiles ?? 10;
    const r = Math.max(4, maxTiles);
    const cx = Math.floor(enemyCore.x/TILE);
    const cy = Math.floor(enemyCore.y/TILE);

    const tx = cx + Math.floor((Math.random()*2-1)*r);
    const ty = cy + Math.floor((Math.random()*2-1)*r);

    const typeRoll = Math.random();
    const tid =
      typeRoll<0.40 ? "r_laser" :
      typeRoll<0.65 ? "r_mortar" :
      typeRoll<0.82 ? "r_field" :
      typeRoll<0.93 ? "r_sniper" : "r_burst";

    if(placeEnemyTower(tx,ty,tid)){
      placed++;
      redEnergy -= (enemyTowerTypes.find(t=>t.id===tid)?.cost||0);
    }
  }
}

/* Player tower placement */
function placeTowerAtTile(tx,ty){
  if(gameOver||victory) return;
  const type = towerTypes[selectedTowerIndex];
  if(!type) return;

  if(!isInside(tx,ty)) return;
  const cell=grid[ty][tx];

  if(cell.isPath){ setStatus("ê²½ë¡œ ìœ„ì—ëŠ” íƒ€ì›Œ ì„¤ì¹˜ ë¶ˆê°€!", "bad"); return; }
  if(cell.hasTower){ setStatus("ì´ë¯¸ íƒ€ì›Œê°€ ìˆìŠµë‹ˆë‹¤.", "warn"); return; }
  if(cell.hasEnemyTower){ setStatus("ì  íƒ€ì›Œê°€ ìˆëŠ” ì¹¸ì…ë‹ˆë‹¤(ë¨¼ì € ì œê±°).", "bad"); return; }
  if(energy < type.cost){ setStatus("ì—ë„ˆì§€ê°€ ë¶€ì¡±í•©ë‹ˆë‹¤!", "bad"); return; }

  const c=tileCenter(tx,ty);
  towers.push({
    id:towerId++,
    x:c.x,y:c.y,
    range:type.baseRange,
    fireRate:type.fireRate,
    cooldown:0,
    damage:type.baseDamage,
    bulletSpeed:type.bulletSpeed,
    splashRadius:type.splashRadius,
    slowFactor:type.slowFactor,
    slowDuration:type.slowDuration,
    poisonDps:type.poisonDps,
    poisonDuration:type.poisonDuration,
    typeId:type.id,
    mode:type.mode,
    hp:type.baseHp,
    maxHp:type.baseHp,
    healAmount:type.healAmount||0,
    spin:Math.random()*Math.PI*2
  });

  cell.hasTower=true;
  energy -= type.cost;
  refreshUI();
  setStatus(`${type.name} ì„¤ì¹˜!`, "good");
}

/* spawn enemies */
function spawnEnemy(type){
  const cfg = enemyConfigs[type] || enemyConfigs.normal;
  const start = pathPoints[0];
  const diff = currentMap?.difficulty ?? 1.0;

  const hpBase = (52 + wave*10) * diff;
  const hp = hpBase * (cfg.hpFactor||1);
  const speed = (cfg.speedBase||1) + wave*(cfg.speedGrow||0.05);

  const e = {
    id:enemyId++,
    type,
    x:start.x,y:start.y,
    hp, maxHp:hp,
    baseSpeed:speed,
    pathIndex:0, progress:0,
    slowTimer:0, slowFactor:1,
    shieldHp:0, shieldMax:0,
    poisonTimer:0, poisonDps:0,
    regenFactor:cfg.regenFactor||0,

    atkRange:cfg.atkRange||140,
    atkRate:cfg.atkRate||70,
    atkCooldown:Math.floor(cfg.atkRate*0.3),
    atkDamage:cfg.atkDamage||6,

    healRadius:cfg.healRadius||0,
    healFactor:cfg.healFactor||0,
    healInterval:cfg.healInterval||999,

    color:cfg.color||"#fff"
  };
  if(type==="shield"){
    e.shieldMax = hp*0.85;
    e.shieldHp = e.shieldMax;
  }
  enemies.push(e);
}

/* ally spawn */
function spawnAllyAtPathIndex(pi){
  if(gameOver||victory) return;
  if(!waveInProgress){
    setStatus("ìœ ë‹› ì†Œí™˜ì€ ì›¨ì´ë¸Œ ì§„í–‰ ì¤‘ì—ë§Œ ê°€ëŠ¥í•©ë‹ˆë‹¤.", "warn");
    return;
  }
  const u = unitTypes[selectedUnitIndex];
  if(!u) return;
  if(energy < u.cost){
    setStatus("ì—ë„ˆì§€ê°€ ë¶€ì¡±í•´ì„œ ì†Œí™˜ ë¶ˆê°€!", "bad");
    return;
  }
  pi = clamp(pi, 0, pathPoints.length-1);

  const p=pathPoints[pi];
  const ally={
    id:allyId++,
    typeId:u.id,
    name:u.name,
    x:p.x,y:p.y,
    hp:u.hp, maxHp:u.hp,
    speed:u.speed,
    range:u.range,
    atkRate:u.atkRate,
    cooldown:0,
    damage:u.damage,
    mode:u.mode,
    bulletSpeed:u.bulletSpeed||11,
    splashRadius:u.splashRadius||0,
    healAmount:u.healAmount||0,
    empSlow:u.empSlow||1,
    empDur:u.empDur||0,
    pathIndex:pi,
    progress:0,

    coreStrikesLeft: u.coreStrikes ?? 6,
    coreCooldown:0,

    bornTick:tick,
    tint:"ally"
  };

  // ì‘ì€ ì‹œë„ˆì§€(ì—°ì† ì†Œí™˜)
  const recentSame = allies.filter(a=>a.typeId===ally.typeId && (tick-a.bornTick)<=210).length;
  if(recentSame>=2){
    ally.damage = Math.floor(ally.damage*1.15);
    ally.maxHp = Math.floor(ally.maxHp*1.12);
    ally.hp = ally.maxHp;
    pulses.push({x:ally.x,y:ally.y,r:0,maxR:140,alpha:0.75,kind:"synergy"});
  }

  energy -= u.cost;
  allies.push(ally);
  refreshUI();
  setStatus(`ìœ ë‹› íˆ¬ì…: ${u.name}`, "good");
}

/* wave creation with map special rules */
function createWave(){
  if(gameOver||victory){ setStatus("ì´ë¯¸ ëë‚¬ìŠµë‹ˆë‹¤. Rë¡œ ì¬ì‹œì‘.", "bad"); return; }
  if(waveInProgress){ setStatus("ì›¨ì´ë¸Œ ì§„í–‰ ì¤‘ì…ë‹ˆë‹¤.", "warn"); return; }

  wave++;
  const diff = currentMap?.difficulty ?? 1.0;

  // enemy resource grows
  redEnergy += Math.floor((160 + wave*32) * diff);
  redBuildCooldown = Math.min(redBuildCooldown, 20);

  spawnQueue=[];
  let delay=0;

  // blackhole special: after certain wave -> only boss
  const sp = currentMap?.special;
  const bossOnly = sp?.bossOnlyAfterWave != null && wave >= sp.bossOnlyAfterWave;

  if(bossOnly){
    const scale = sp?.bossOnlyScale ?? 1.15;
    const count = Math.max(2, Math.floor((3 + wave*0.35) * scale));
    for(let i=0;i<count;i++){
      spawnQueue.push({type:"boss", spawnTick: tick + delay});
      delay += 85;
    }
    setStatus(`Wave ${wave}: ì‚¬ê±´ì§€í‰ì„  â€” Reich Carrier ì—°ì† íˆ¬ì…`, "warn");
  }else{
    const baseCount = Math.floor((10 + wave*3) * diff);
    for(let i=0;i<baseCount;i++){
      let type;
      if (wave>=13 && i%12===0) type="medic";
      else if (wave>=12 && i%10===0) type="bomber";
      else if (wave>=11 && i%9 ===0) type="brute";
      else if (wave>=10 && i%8 ===0) type="shield";
      else if (wave>=9  && i%7 ===0) type="regen";
      else if (wave>=8  && i%6 ===0) type="tank";
      else if (wave>=7  && i%5 ===0) type="sniper";
      else if (wave>=6  && i%4 ===0) type="swarm";
      else if (wave>=4  && i%3 ===0) type="fast";
      else type="normal";
      spawnQueue.push({type, spawnTick: tick+delay});
      delay += (type==="swarm"?18:36);
    }
    if(wave % 5 === 0) spawnQueue.push({type:"boss", spawnTick: tick+delay+80});
    setStatus(`Wave ${wave} ì‹œì‘!`, "good");
  }

  waveInProgress=true;

  // small energy drip
  energy += 25;
  refreshUI();
}

/* damage helpers */
function applySlow(target, slowFactor, slowDuration){
  if(!slowDuration || slowFactor>=1) return;
  if(target.slowTimer==null){
    target.slowTimer=0;
    target.slowFactor=1;
  }
  // apply stronger slow
  if(slowFactor < target.slowFactor){
    target.slowFactor = slowFactor;
    target.slowTimer = Math.max(target.slowTimer, slowDuration);
  }
}

function applyDamageToEnemy(e, dmg, slowFactor=1, slowDuration=0, poisonDps=0, poisonDuration=0){
  if(e.shieldHp>0){
    const used=Math.min(e.shieldHp,dmg);
    e.shieldHp-=used;
    dmg-=used;
  }
  if(dmg>0) e.hp-=dmg;

  if(slowDuration>0) applySlow(e, slowFactor, slowDuration);
  if(poisonDuration>0 && poisonDps>0){
    e.poisonDps = Math.max(e.poisonDps||0, poisonDps);
    e.poisonTimer = Math.max(e.poisonTimer||0, poisonDuration);
  }
}

function applyDamageToEnemyTower(tw, dmg, slowFactor=1, slowDuration=0){
  tw.hp -= dmg;
  if(slowDuration>0) applySlow(tw, slowFactor, slowDuration);
}

function applyDamageToCore(dmg){
  if(!enemyCore) return;
  enemyCore.hp -= dmg;
  pulses.push({x:enemyCore.x,y:enemyCore.y,r:0,maxR:180,alpha:0.65,kind:"coreHit"});
  if(enemyCore.hp<=0){
    enemyCore.hp=0;
    triggerVictory(true);
  }
}

/* victory / progression: clear map -> unlock next map (or next episode) */
function fadeTo(url){
  const f=document.getElementById("fadeOverlay");
  if(!f){ window.location.href=url; return; }
  f.style.pointerEvents="auto";
  requestAnimationFrame(()=>{ f.style.opacity="1"; });
  setTimeout(()=>{ window.location.href=url; }, 620);
}

function showEpilogue(){
  const back=document.getElementById("epilogueBack");
  if(back) back.style.display="flex";
}

function triggerVictory(byCore){
  if(victory) return;
  victory=true;
  waveInProgress=false;
  spawnQueue=[];
  const bonus = byCore ? 300 : 200;
  energy += bonus;
  refreshUI();

  const prog = loadProgress();
  const ekey = String(currentEp);
  const unlockedEp = prog.unlockedEpisode ?? 0;
  const unlockedMap = prog.unlockedMapByEpisode?.[ekey] ?? 0;

  // advance within episode
  if(currentEp < unlockedEp){
    // already beyond, don't change
  }else if(currentEp === unlockedEp){
    if(currentMapIndexInEpisode >= unlockedMap){
      if(currentMapIndexInEpisode < 2){
        prog.unlockedMapByEpisode[ekey] = currentMapIndexInEpisode + 1;
      }else{
        // unlock next episode
        prog.unlockedEpisode = Math.min(episodes.length-1, unlockedEp + 1);
        const nextKey = String(prog.unlockedEpisode);
        if(prog.unlockedMapByEpisode[nextKey]==null) prog.unlockedMapByEpisode[nextKey]=0;
      }
    }
  }
  saveProgress(prog);
  rebuildMapSelect();

  const isFinal = (currentEp===episodes.length-1) && (currentMapIndexInEpisode===2);
  if(isFinal){
    // lock selection and show epilogue CTA
    setStatus("ë‹¬ ì•ë©´ ìµœì¢… ì „ì—­ í´ë¦¬ì–´! ì—í•„ë¡œê·¸ë¥¼ í™•ì¸í•˜ì„¸ìš”.", "good");
    showEpilogue();
    return;
  }

  setStatus(byCore ? `ìŠ¹ë¦¬! ì  ì½”ì–´ íŒŒê´´ (+${bonus}âš¡)` : `í´ë¦¬ì–´! ëª©í‘œ ì›¨ì´ë¸Œ ë‹¬ì„± (+${bonus}âš¡)`, "good");
}

/* enemy AI: build towers near core */
function enemyBuildAI(){
  if(gameOver||victory) return;
  if(enemyTowers.length >= (currentMap.enemyTowerMax||12)) return;

  if(redBuildCooldown>0){ redBuildCooldown--; return; }
  if(redEnergy < 120) return;

  // choose type by wave
  let pick;
  if(wave>=12 && Math.random()<0.25) pick="r_burst";
  else if(wave>=10 && Math.random()<0.20) pick="r_sniper";
  else if(wave>=8 && Math.random()<0.25) pick="r_field";
  else if(wave>=6 && Math.random()<0.28) pick="r_mortar";
  else pick="r_laser";

  const type = enemyTowerTypes.find(t=>t.id===pick) || enemyTowerTypes[0];
  if(!type) return;
  if(redEnergy < type.cost) return;

  const cx = Math.floor(enemyCore.x/TILE);
  const cy = Math.floor(enemyCore.y/TILE);
  const R = currentMap.enemyTowerRadiusTiles ?? 10;

  let placed=false;
  for(let tries=0; tries<220; tries++){
    const tx = cx + Math.floor((Math.random()*2-1)*R);
    const ty = cy + Math.floor((Math.random()*2-1)*R);
    if(placeEnemyTower(tx,ty, type.id)){ placed=true; break; }
  }

  if(placed){
    redEnergy -= type.cost;
    redBuildCooldown = 70 - Math.min(35, wave*2);
    pulses.push({x:enemyCore.x,y:enemyCore.y,r:0,maxR:160,alpha:0.55,kind:"enemyBuild"});
  }else{
    redBuildCooldown = 30;
  }
}

/* updates */
function updateEnemies(){
  // spawn schedule
  if(waveInProgress && spawnQueue.length>0){
    while(spawnQueue.length>0 && spawnQueue[0].spawnTick<=tick){
      const s=spawnQueue.shift();
      spawnEnemy(s.type);
    }
  }

  for(let i=enemies.length-1;i>=0;i--){
    const e=enemies[i];

    // status
    if(e.slowTimer>0){ e.slowTimer--; if(e.slowTimer<=0) e.slowFactor=1; }
    if(e.poisonTimer>0 && e.poisonDps>0){ e.poisonTimer--; e.hp -= e.poisonDps; }
    if(e.type==="shield"){
      if(tick%40===0 && e.shieldHp<e.shieldMax){
        e.shieldHp = Math.min(e.shieldMax, e.shieldHp + e.maxHp*0.05);
      }
    }
    if(e.regenFactor>0 && tick%35===0){
      e.hp = Math.min(e.maxHp, e.hp + e.maxHp*e.regenFactor);
    }
    if(e.type==="medic" && e.healRadius>0 && e.healFactor>0){
      if(tick % e.healInterval === 0){
        let healed=false;
        for(const other of enemies){
          if(other===e) continue;
          if(dist(e,other) <= e.healRadius){
            const before=other.hp;
            other.hp = Math.min(other.maxHp, other.hp + other.maxHp*e.healFactor);
            if(other.hp>before) healed=true;
          }
        }
        if(healed) pulses.push({x:e.x,y:e.y,r:0,maxR:e.healRadius*0.85,alpha:0.7,kind:"enemyHeal"});
      }
    }

    // movement along path toward player base
    const from = pathPoints[e.pathIndex];
    const to = pathPoints[e.pathIndex+1];
    if(!to){
      // reached player base
      enemies.splice(i,1);
      lives -= 1;
      if(lives<=0){
        lives=0;
        gameOver=true;
        waveInProgress=false;
        spawnQueue=[];
        setStatus("MISSION FAILED... Rë¡œ ì¬ì‹œì‘", "bad");
      }else{
        setStatus("ì ì´ ê¸°ì§€ì— ë„ë‹¬í–ˆìŠµë‹ˆë‹¤!", "bad");
      }
      continue;
    }
    const dx=to.x-from.x, dy=to.y-from.y;
    const segLen=Math.sqrt(dx*dx+dy*dy)||1;
    const step = e.baseSpeed * (e.slowFactor||1);
    e.progress += step/segLen;
    if(e.progress>=1){
      e.pathIndex++;
      e.progress=0;
    }
    const base=pathPoints[e.pathIndex];
    const tgt=pathPoints[e.pathIndex+1]||base;
    e.x = base.x + (tgt.x-base.x)*e.progress;
    e.y = base.y + (tgt.y-base.y)*e.progress;

    // enemy attack: prefer nearest ally, then player tower
    if(e.atkCooldown>0) e.atkCooldown--;
    if(e.atkCooldown<=0){
      let target=null, kind="";
      let best=Infinity;

      for(const a of allies){
        const d=dist(e,a);
        if(d<e.atkRange && d<best){ best=d; target=a; kind="ally"; }
      }
      for(const t of towers){
        const d=dist(e,t);
        if(d<e.atkRange && d<best){ best=d; target=t; kind="tower"; }
      }

      if(target){
        let splash=40;
        if(e.type==="tank") splash=70;
        else if(e.type==="boss") splash=95;
        else if(e.type==="bomber") splash=110;
        else if(e.type==="sniper") splash=30;

        enemyBullets.push({
          x:e.x,y:e.y,
          targetId:target.id,
          targetKind:kind,
          tx:target.x, ty:target.y,
          speed:6.3,
          damage:e.atkDamage,
          splashRadius:splash
        });
        e.atkCooldown=e.atkRate;
      }
    }

    if(e.hp<=0){
      enemies.splice(i,1);
      energy += (8 + wave*2);
      redEnergy += 10; // ì ë„ ì „ì¥ ìì› ì¡°ê¸ˆ
    }
  }

  // wave end condition
  if(waveInProgress && spawnQueue.length===0 && enemies.length===0 && !gameOver && !victory){
    waveInProgress=false;
    const reward = Math.floor(80 + wave*22);
    energy += reward;
    setStatus(`Wave ${wave} ë°©ì–´ ì„±ê³µ! +${reward} âš¡`, "good");

    // map goal
    if(wave >= (currentMap?.clearWaves ?? 6)){
      triggerVictory(false);
    }
  }
}

function updateEnemyTowers(){
  enemyBuildAI();

  for(const tw of enemyTowers){
    if(tw.slowTimer>0){ tw.slowTimer--; if(tw.slowTimer<=0) tw.slowFactor=1; }
    if(tw.cooldown>0) tw.cooldown--;

    // choose target: nearest ally first, then player tower
    let target=null, kind="";
    let best=Infinity;

    for(const a of allies){
      const d=dist(tw,a);
      if(d<tw.range && d<best){best=d; target=a; kind="ally";}
    }
    for(const t of towers){
      const d=dist(tw,t);
      if(d<tw.range && d<best){best=d; target=t; kind="tower";}
    }

    if(target && tw.cooldown<=0){
      if(tw.mode==="pulse"){
        const radius = tw.range*0.82;
        // pulse hits nearby allies/towers
        for(const a of allies){
          if(dist(tw,a)<=radius) a.hp -= tw.damage;
        }
        for(const t of towers){
          if(dist(tw,t)<=radius) t.hp -= tw.damage;
        }
        pulses.push({x:tw.x,y:tw.y,r:0,maxR:radius,alpha:0.7,kind:"redPulse"});
      }else{
        enemyTowerBullets.push({
          x:tw.x,y:tw.y,
          targetId:target.id,
          targetKind:kind,
          tx:target.x, ty:target.y,
          speed:tw.bulletSpeed||8,
          damage:tw.damage,
          splashRadius:tw.splashRadius||0,
          slowFactor:tw.slowFactor||1,
          slowDuration:tw.slowDuration||0
        });
      }
      tw.cooldown = tw.fireRate;
    }
    tw.spin += 0.05;
  }

  // remove dead enemy towers (and clear tile)
  for(let i=enemyTowers.length-1;i>=0;i--){
    const tw=enemyTowers[i];
    if(tw.hp<=0){
      const tx=Math.floor(tw.x/TILE);
      const ty=Math.floor(tw.y/TILE);
      if(isInside(tx,ty)) grid[ty][tx].hasEnemyTower=false;
      enemyTowers.splice(i,1);
      energy += 18; // reward for destroying defenses
      setStatus("ì  íƒ€ì›Œ íŒŒê´´! (+18âš¡)", "good");
    }
  }
}

function updateTowers(){
  for(const t of towers){
    if(t.cooldown>0) t.cooldown--;

    if(t.mode==="heal"){
      if(t.cooldown<=0){
        let healed=false;
        for(const other of towers){
          if(other===t) continue;
          if(dist(t,other)<=t.range){
            const before=other.hp;
            other.hp = Math.min(other.maxHp, other.hp + t.healAmount);
            if(other.hp>before) healed=true;
          }
        }
        if(healed) pulses.push({x:t.x,y:t.y,r:0,maxR:t.range*0.7,alpha:0.55,kind:"towerHeal"});
        t.cooldown=t.fireRate;
      }
      t.spin += 0.05;
      continue;
    }

    // target priority: enemy units -> enemy towers -> core
    let targetE=null, bestE=Infinity;
    for(const e of enemies){
      const d=dist(t,e);
      if(d<t.range && d<bestE){bestE=d; targetE=e;}
    }
    let targetTw=null, bestTw=Infinity;
    if(!targetE){
      for(const tw of enemyTowers){
        const d=dist(t,tw);
        if(d<t.range && d<bestTw){bestTw=d; targetTw=tw;}
      }
    }
    const canHitCore = (!targetE && !targetTw && enemyCore && dist(t,enemyCore)<=t.range);

    if(t.mode==="pulse"){
      if(t.cooldown<=0 && (targetE||targetTw||canHitCore)){
        const radius=t.range*0.88;
        for(const e of enemies){
          if(dist(t,e)<=radius) applyDamageToEnemy(e, t.damage, 1,0,0,0);
        }
        for(const tw of enemyTowers){
          if(dist(t,tw)<=radius) applyDamageToEnemyTower(tw, t.damage, t.slowFactor, t.slowDuration);
        }
        if(enemyCore && dist(t,enemyCore)<=radius) applyDamageToCore(Math.floor(t.damage*0.65));
        pulses.push({x:t.x,y:t.y,r:0,maxR:radius,alpha:0.7,kind:"pulse"});
        t.cooldown=t.fireRate;
      }
    }else{
      if(t.cooldown<=0 && (targetE||targetTw||canHitCore)){
        const tx = targetE?targetE.x:(targetTw?targetTw.x:enemyCore.x);
        const ty = targetE?targetE.y:(targetTw?targetTw.y:enemyCore.y);
        bullets.push({
          x:t.x,y:t.y,
          targetKind: targetE?"enemy":(targetTw?"enemyTower":"core"),
          targetId: targetE?targetE.id:(targetTw?targetTw.id:0),
          tx,ty,
          speed:t.bulletSpeed,
          damage:t.damage,
          splashRadius:t.splashRadius,
          slowFactor:t.slowFactor,
          slowDuration:t.slowDuration,
          poisonDps:t.poisonDps,
          poisonDuration:t.poisonDuration,
          towerType:t.typeId
        });
        t.cooldown=t.fireRate;
      }
    }
    t.spin += 0.05;
  }

  // remove destroyed player towers
  for(let i=towers.length-1;i>=0;i--){
    const t=towers[i];
    if(t.hp<=0){
      const tx=Math.floor(t.x/TILE), ty=Math.floor(t.y/TILE);
      if(isInside(tx,ty)) grid[ty][tx].hasTower=false;
      towers.splice(i,1);
      setStatus("ì•„êµ° íƒ€ì›Œê°€ íŒŒê´´ë˜ì—ˆìŠµë‹ˆë‹¤!", "bad");
    }
  }
}

function updateAllies(){
  for(let i=allies.length-1;i>=0;i--){
    const a=allies[i];
    if(a.hp<=0){ allies.splice(i,1); continue; }

    if(a.slowTimer>0){ a.slowTimer--; if(a.slowTimer<=0) a.slowFactor=1; }
    if(a.cooldown>0) a.cooldown--;
    if(a.coreCooldown>0) a.coreCooldown--;

    // heal mode
    if(a.mode==="heal"){
      if(a.cooldown<=0){
        let healed=false;
        for(const other of allies){
          if(other===a) continue;
          if(dist(a,other)<=a.range){
            const before=other.hp;
            other.hp = Math.min(other.maxHp, other.hp + a.healAmount);
            if(other.hp>before) healed=true;
          }
        }
        if(healed) pulses.push({x:a.x,y:a.y,r:0,maxR:a.range*0.75,alpha:0.55,kind:"allyHeal"});
        a.cooldown=a.atkRate;
      }
    }else{
      // target priority: enemy near -> enemy tower -> core
      let targetE=null, bestE=Infinity;
      for(const e of enemies){
        const d=dist(a,e);
        if(d<a.range && d<bestE){bestE=d; targetE=e;}
      }
      let targetTw=null, bestTw=Infinity;
      if(!targetE){
        for(const tw of enemyTowers){
          const d=dist(a,tw);
          if(d<a.range && d<bestTw){bestTw=d; targetTw=tw;}
        }
      }
      const canHitCore = (!targetE && !targetTw && enemyCore && dist(a,enemyCore)<=a.range);

      if(a.cooldown<=0){
        if(targetE){
          if(a.mode==="melee"){
            applyDamageToEnemy(targetE, a.damage);
            pulses.push({x:targetE.x,y:targetE.y,r:0,maxR:55,alpha:0.45,kind:"melee"});
          }else if(a.mode==="emp"){
            allyBullets.push({
              x:a.x,y:a.y, targetKind:"enemy", targetId:targetE.id,
              tx:targetE.x, ty:targetE.y, speed:a.bulletSpeed,
              damage:a.damage, splashRadius:0,
              empSlow:a.empSlow, empDur:a.empDur
            });
          }else{
            allyBullets.push({
              x:a.x,y:a.y, targetKind:"enemy", targetId:targetE.id,
              tx:targetE.x, ty:targetE.y, speed:a.bulletSpeed,
              damage:a.damage, splashRadius:a.splashRadius||0
            });
          }
          a.cooldown=a.atkRate;
        }else if(targetTw){
          if(a.mode==="melee"){
            applyDamageToEnemyTower(targetTw, a.damage);
            pulses.push({x:targetTw.x,y:targetTw.y,r:0,maxR:55,alpha:0.45,kind:"melee"});
          }else if(a.mode==="emp"){
            allyBullets.push({
              x:a.x,y:a.y, targetKind:"enemyTower", targetId:targetTw.id,
              tx:targetTw.x, ty:targetTw.y, speed:a.bulletSpeed,
              damage:a.damage, splashRadius:0,
              empSlow:a.empSlow, empDur:a.empDur
            });
          }else{
            allyBullets.push({
              x:a.x,y:a.y, targetKind:"enemyTower", targetId:targetTw.id,
              tx:targetTw.x, ty:targetTw.y, speed:a.bulletSpeed,
              damage:a.damage, splashRadius:a.splashRadius||0
            });
          }
          a.cooldown=a.atkRate;
        }else if(canHitCore){
          if(a.mode==="melee"){
            if(a.coreStrikesLeft>0 && a.coreCooldown<=0){
              applyDamageToCore(a.damage);
              a.coreStrikesLeft--;
              a.coreCooldown = Math.max(8, Math.floor(a.atkRate*0.55));
              pulses.push({x:enemyCore.x,y:enemyCore.y,r:0,maxR:70,alpha:0.5,kind:"corePoke"});
              if(a.coreStrikesLeft<=0){
                allies.splice(i,1); // "ëª‡ë²ˆ ê³µê²©í•˜ê³  ì‚¬ë¼ì§"
                continue;
              }
            }
          }else{
            allyBullets.push({
              x:a.x,y:a.y, targetKind:"core", targetId:0,
              tx:enemyCore.x, ty:enemyCore.y, speed:a.bulletSpeed,
              damage:a.damage, splashRadius:a.splashRadius||0,
              empSlow:a.empSlow||1, empDur:a.empDur||0
            });
          }
          a.cooldown=a.atkRate;
        }
      }
    }

    // move toward enemy core: reverse along path (decrease index)
    // stop at index 0 region, don't warp
    const slow = (a.slowFactor||1);
    const moveSpeed = a.speed * slow;

    // if already near core tile
    if(a.pathIndex<=0){
      // keep around core point
      a.x = pathPoints[0].x;
      a.y = pathPoints[0].y;
      continue;
    }

    const from = pathPoints[a.pathIndex];
    const to = pathPoints[a.pathIndex-1];
    const dx=to.x-from.x, dy=to.y-from.y;
    const segLen=Math.sqrt(dx*dx+dy*dy)||1;

    a.progress += moveSpeed/segLen;
    if(a.progress>=1){
      a.pathIndex--;
      a.progress=0;
    }
    const base = pathPoints[a.pathIndex];
    const tgt  = pathPoints[a.pathIndex-1] || base;
    a.x = base.x + (tgt.x-base.x)*a.progress;
    a.y = base.y + (tgt.y-base.y)*a.progress;
  }
}

function updateProjectiles(){
  // player tower bullets
  for(let i=bullets.length-1;i>=0;i--){
    const b=bullets[i];

    let tx=b.tx, ty=b.ty;
    if(b.targetKind==="enemy"){
      const te = enemies.find(e=>e.id===b.targetId);
      if(te){ tx=te.x; ty=te.y; b.tx=tx; b.ty=ty; }
    }else if(b.targetKind==="enemyTower"){
      const tw = enemyTowers.find(t=>t.id===b.targetId);
      if(tw){ tx=tw.x; ty=tw.y; b.tx=tx; b.ty=ty; }
    }else if(b.targetKind==="core"){
      if(enemyCore){ tx=enemyCore.x; ty=enemyCore.y; b.tx=tx; b.ty=ty; }
    }

    const dx=tx-b.x, dy=ty-b.y;
    const len=Math.sqrt(dx*dx+dy*dy)||1;
    b.x += (dx/len)*b.speed;
    b.y += (dy/len)*b.speed;

    if(Math.sqrt((tx-b.x)**2+(ty-b.y)**2) < 10){
      if(b.splashRadius>0){
        const hitPoint={x:b.x,y:b.y};
        // affect enemies
        for(const e of enemies){
          if(dist(hitPoint,e)<=b.splashRadius){
            applyDamageToEnemy(e, b.damage, b.slowFactor, b.slowDuration, b.poisonDps, b.poisonDuration);
          }
        }
        // affect enemy towers
        for(const tw of enemyTowers){
          if(dist(hitPoint,tw)<=b.splashRadius){
            applyDamageToEnemyTower(tw, b.damage, b.slowFactor, b.slowDuration);
          }
        }
        // core
        if(enemyCore && dist(hitPoint,enemyCore)<=b.splashRadius){
          applyDamageToCore(Math.floor(b.damage*0.55));
        }
      }else{
        if(b.targetKind==="enemy"){
          const te = enemies.find(e=>e.id===b.targetId);
          if(te) applyDamageToEnemy(te, b.damage, b.slowFactor, b.slowDuration, b.poisonDps, b.poisonDuration);
        }else if(b.targetKind==="enemyTower"){
          const tw = enemyTowers.find(t=>t.id===b.targetId);
          if(tw) applyDamageToEnemyTower(tw, b.damage, b.slowFactor, b.slowDuration);
        }else{
          applyDamageToCore(b.damage);
        }
      }
      bullets.splice(i,1);
    }
  }

  // ally bullets
  for(let i=allyBullets.length-1;i>=0;i--){
    const b=allyBullets[i];
    let tx=b.tx, ty=b.ty;

    if(b.targetKind==="enemy"){
      const te=enemies.find(e=>e.id===b.targetId);
      if(te){ tx=te.x; ty=te.y; b.tx=tx; b.ty=ty; }
    }else if(b.targetKind==="enemyTower"){
      const tw=enemyTowers.find(t=>t.id===b.targetId);
      if(tw){ tx=tw.x; ty=tw.y; b.tx=tx; b.ty=ty; }
    }else if(b.targetKind==="core"){
      if(enemyCore){ tx=enemyCore.x; ty=enemyCore.y; b.tx=tx; b.ty=ty; }
    }

    const dx=tx-b.x, dy=ty-b.y;
    const len=Math.sqrt(dx*dx+dy*dy)||1;
    b.x += (dx/len)*b.speed;
    b.y += (dy/len)*b.speed;

    if(Math.sqrt((tx-b.x)**2+(ty-b.y)**2) < 10){
      if(b.targetKind==="core"){
        applyDamageToCore(b.damage);
      }else if(b.targetKind==="enemy"){
        if(b.splashRadius>0){
          const hitPoint={x:b.x,y:b.y};
          for(const e of enemies){
            if(dist(hitPoint,e)<=b.splashRadius) applyDamageToEnemy(e, b.damage);
          }
        }else{
          const te=enemies.find(e=>e.id===b.targetId);
          if(te){
            applyDamageToEnemy(te, b.damage);
            // EMP special
            if(b.empDur){
              applySlow(te, b.empSlow||0.6, b.empDur);
              te.atkCooldown = Math.max(te.atkCooldown, 18);
              pulses.push({x:te.x,y:te.y,r:0,maxR:120,alpha:0.6,kind:"emp"});
            }
          }
        }
      }else if(b.targetKind==="enemyTower"){
        const tw=enemyTowers.find(t=>t.id===b.targetId);
        if(tw){
          applyDamageToEnemyTower(tw, b.damage);
          if(b.empDur){
            applySlow(tw, b.empSlow||0.6, b.empDur);
            tw.cooldown = Math.max(tw.cooldown, 20);
            pulses.push({x:tw.x,y:tw.y,r:0,maxR:140,alpha:0.6,kind:"emp"});
          }
        }
      }
      allyBullets.splice(i,1);
    }
  }

  // enemy unit bullets
  for(let i=enemyBullets.length-1;i>=0;i--){
    const b=enemyBullets[i];
    let tx=b.tx, ty=b.ty;

    if(b.targetKind==="tower"){
      const t=towers.find(x=>x.id===b.targetId);
      if(t){ tx=t.x; ty=t.y; b.tx=tx; b.ty=ty; }
    }else{
      const a=allies.find(x=>x.id===b.targetId);
      if(a){ tx=a.x; ty=a.y; b.tx=tx; b.ty=ty; }
    }

    const dx=tx-b.x, dy=ty-b.y;
    const len=Math.sqrt(dx*dx+dy*dy)||1;
    b.x += (dx/len)*b.speed;
    b.y += (dy/len)*b.speed;

    if(Math.sqrt((tx-b.x)**2+(ty-b.y)**2) < 10){
      const hitPoint={x:b.x,y:b.y};
      for(let j=allies.length-1;j>=0;j--){
        const a=allies[j];
        if(dist(hitPoint,a)<=b.splashRadius){
          a.hp -= b.damage;
          if(a.hp<=0) allies.splice(j,1);
        }
      }
      for(let j=towers.length-1;j>=0;j--){
        const t=towers[j];
        if(dist(hitPoint,t)<=b.splashRadius){
          t.hp -= b.damage;
        }
      }
      enemyBullets.splice(i,1);
    }
  }

  // enemy tower bullets (separate for clarity)
  for(let i=enemyTowerBullets.length-1;i>=0;i--){
    const b=enemyTowerBullets[i];
    let tx=b.tx, ty=b.ty;

    if(b.targetKind==="tower"){
      const t=towers.find(x=>x.id===b.targetId);
      if(t){ tx=t.x; ty=t.y; b.tx=tx; b.ty=ty; }
    }else{
      const a=allies.find(x=>x.id===b.targetId);
      if(a){ tx=a.x; ty=a.y; b.tx=tx; b.ty=ty; }
    }

    const dx=tx-b.x, dy=ty-b.y;
    const len=Math.sqrt(dx*dx+dy*dy)||1;
    b.x += (dx/len)*b.speed;
    b.y += (dy/len)*b.speed;

    if(Math.sqrt((tx-b.x)**2+(ty-b.y)**2) < 10){
      const hitPoint={x:b.x,y:b.y};
      for(let j=allies.length-1;j>=0;j--){
        const a=allies[j];
        if(dist(hitPoint,a)<=b.splashRadius){
          a.hp -= b.damage;
          if(b.slowDuration) applySlow(a, b.slowFactor||0.6, b.slowDuration);
          if(a.hp<=0) allies.splice(j,1);
        }
      }
      for(let j=towers.length-1;j>=0;j--){
        const t=towers[j];
        if(dist(hitPoint,t)<=b.splashRadius){
          t.hp -= b.damage;
          if(b.slowDuration) applySlow(t, b.slowFactor||0.7, b.slowDuration);
        }
      }
      enemyTowerBullets.splice(i,1);
    }
  }
}

function updatePulses(){
  for(let i=pulses.length-1;i>=0;i--){
    const p=pulses[i];
    p.r += 6;
    p.alpha -= 0.03;
    if(p.alpha<=0 || p.r>p.maxR) pulses.splice(i,1);
  }
}

/* render */
function drawBackground(){
  resetTransform();
  const g=ctx.createRadialGradient(CW*0.5, CH*0.12, 60, CW*0.5, CH*0.5, CW*0.95);
  g.addColorStop(0,"#1a1d4f");
  g.addColorStop(0.45,"#050119");
  g.addColorStop(1,"#020008");
  ctx.fillStyle=g;
  ctx.fillRect(0,0,CW,CH);

  // stars
  for(const s of stars){
    const tw = 0.4 + Math.sin(tick*0.04*s.t)*0.3;
    ctx.beginPath();
    ctx.arc(s.x, s.y, s.r + tw*0.85, 0, Math.PI*2);
    ctx.fillStyle = `rgba(240,248,255,${0.28+tw})`;
    ctx.fill();
  }
}

function drawWorld(){
  setWorldTransform();

  // subtle ground tiles (ë§µì´ "ì•ˆ ë³´ì´ëŠ”" ëŠë‚Œ ë°©ì§€)
  ctx.save();
  for(let y=0;y<ROWS;y++){
    for(let x=0;x<COLS;x++){
      const c = grid[y][x];
      const px=x*TILE, py=y*TILE;
      if(c.isPath){
        ctx.fillStyle = "rgba(74,242,197,0.06)";
      }else{
        ctx.fillStyle = "rgba(120,140,255,0.03)";
      }
      ctx.fillRect(px,py,TILE,TILE);
    }
  }
  ctx.restore();

  // grid lines
  ctx.save();
  ctx.strokeStyle="rgba(120,140,255,0.10)";
  ctx.lineWidth=1;
  for(let x=0;x<=COLS;x++){
    ctx.beginPath(); ctx.moveTo(x*TILE,0); ctx.lineTo(x*TILE,ROWS*TILE); ctx.stroke();
  }
  for(let y=0;y<=ROWS;y++){
    ctx.beginPath(); ctx.moveTo(0,y*TILE); ctx.lineTo(COLS*TILE,y*TILE); ctx.stroke();
  }
  ctx.restore();

  // path glow
  ctx.save();
  ctx.strokeStyle="rgba(74,242,197,0.62)";
  ctx.lineWidth=Math.max(16, TILE*0.42);
  ctx.lineCap="round";
  ctx.shadowColor="rgba(74,242,197,0.75)";
  ctx.shadowBlur=14;
  ctx.beginPath();
  for(let i=0;i<pathPoints.length;i++){
    const p=pathPoints[i];
    if(i===0) ctx.moveTo(p.x,p.y);
    else ctx.lineTo(p.x,p.y);
  }
  ctx.stroke();
  ctx.restore();

  // cores
  if(enemyCore){
    ctx.save();
    ctx.translate(enemyCore.x, enemyCore.y);
    ctx.shadowColor="#ff4b81";
    ctx.shadowBlur=22;

    ctx.beginPath();
    ctx.arc(0,0,22,0,Math.PI*2);
    ctx.fillStyle="rgba(255,75,129,0.92)";
    ctx.fill();

    ctx.beginPath();
    ctx.arc(0,0,36,0,Math.PI*2);
    ctx.strokeStyle="rgba(255,75,129,0.36)";
    ctx.lineWidth=5;
    ctx.stroke();
    ctx.restore();

    const barW=210, barH=9;
    const r = enemyCore.hp/enemyCore.maxHp;
    ctx.fillStyle="rgba(0,0,0,0.6)";
    ctx.fillRect(enemyCore.x-barW/2, enemyCore.y-60, barW, barH);
    ctx.fillStyle="#ff4b81";
    ctx.fillRect(enemyCore.x-barW/2, enemyCore.y-60, barW*Math.max(0,r), barH);
  }

  if(playerCore){
    ctx.save();
    ctx.translate(playerCore.x, playerCore.y);
    ctx.shadowColor="#4af2c5";
    ctx.shadowBlur=18;
    ctx.beginPath();
    ctx.arc(0,0,18,0,Math.PI*2);
    ctx.fillStyle="rgba(74,242,197,0.9)";
    ctx.fill();
    ctx.beginPath();
    ctx.arc(0,0,30,0,Math.PI*2);
    ctx.strokeStyle="rgba(74,242,197,0.25)";
    ctx.lineWidth=4;
    ctx.stroke();
    ctx.restore();
  }

  // pulses
  ctx.save();
  for(const p of pulses){
    ctx.beginPath();
    ctx.arc(p.x,p.y,p.r,0,Math.PI*2);
    let col="rgba(255,235,130,";
    if(p.kind==="towerHeal") col="rgba(102,255,196,";
    if(p.kind==="allyHeal")  col="rgba(100,220,255,";
    if(p.kind==="enemyHeal") col="rgba(129,212,250,";
    if(p.kind==="coreHit")   col="rgba(255,75,129,";
    if(p.kind==="synergy")   col="rgba(74,242,197,";
    if(p.kind==="melee")     col="rgba(255,255,255,";
    if(p.kind==="redPulse")  col="rgba(255,75,129,";
    if(p.kind==="enemyBuild")col="rgba(255,235,130,";
    if(p.kind==="emp")       col="rgba(144,202,249,";
    if(p.kind==="corePoke")  col="rgba(255,255,255,";
    ctx.strokeStyle = col + p.alpha + ")";
    ctx.lineWidth=3;
    ctx.stroke();
  }
  ctx.restore();

  // projectiles
  ctx.save();
  ctx.lineWidth=2;
  ctx.shadowBlur=14;

  ctx.shadowColor="#f8ffff";
  for(const b of bullets){
    ctx.beginPath();
    ctx.moveTo(b.x,b.y);
    ctx.lineTo(b.x+(b.tx-b.x)*0.35, b.y+(b.ty-b.y)*0.35);
    let c="#f8fdff";
    if(b.towerType==="rail") c="#b3ffff";
    else if(b.towerType==="missile") c="#ffcc80";
    else if(b.towerType==="slow") c="#b39ddb";
    else if(b.towerType==="poison") c="#a5d6a7";
    else if(b.towerType==="tachyon") c="#ffffff";
    ctx.strokeStyle=c;
    ctx.stroke();
  }

  ctx.shadowColor="#c8ffff";
  for(const b of allyBullets){
    ctx.beginPath();
    ctx.moveTo(b.x,b.y);
    ctx.lineTo(b.x+(b.tx-b.x)*0.35, b.y+(b.ty-b.y)*0.35);
    ctx.strokeStyle = (b.targetKind==="core") ? "#ffb3c7" : "#e8ffff";
    ctx.stroke();
  }

  ctx.shadowColor="#ff6b6b";
  for(const b of enemyBullets){
    ctx.beginPath();
    ctx.moveTo(b.x,b.y);
    ctx.lineTo(b.x+(b.tx-b.x)*0.35, b.y+(b.ty-b.y)*0.35);
    ctx.strokeStyle="#ff6b6b";
    ctx.stroke();
  }

  ctx.shadowColor="#ff6b6b";
  for(const b of enemyTowerBullets){
    ctx.beginPath();
    ctx.moveTo(b.x,b.y);
    ctx.lineTo(b.x+(b.tx-b.x)*0.35, b.y+(b.ty-b.y)*0.35);
    ctx.strokeStyle="#ff8aa8";
    ctx.stroke();
  }
  ctx.restore();

  // enemy units (triangle, pink outline)
  for(const e of enemies){
    ctx.save();
    ctx.translate(e.x,e.y);
    const from=pathPoints[e.pathIndex];
    const to=pathPoints[e.pathIndex+1]||from;
    const ang=Math.atan2(to.y-from.y,to.x-from.x);
    ctx.rotate(ang);

    const size = e.type==="boss" ? 28 : (e.type==="swarm" ? 12 : 16);
    ctx.shadowColor=e.color;
    ctx.shadowBlur=18;

    ctx.beginPath();
    ctx.moveTo(size,0);
    ctx.lineTo(-size*0.85,-size*0.72);
    ctx.lineTo(-size*0.85, size*0.72);
    ctx.closePath();
    ctx.fillStyle=e.color;
    ctx.fill();

    ctx.lineWidth=2;
    ctx.strokeStyle="rgba(0,0,0,0.35)";
    ctx.stroke();

    if(e.shieldHp>0){
      const rr=e.shieldHp/e.shieldMax;
      ctx.beginPath();
      ctx.arc(0,0,size+4+rr*5,0,Math.PI*2);
      ctx.strokeStyle=`rgba(163,139,255,${0.35+rr*0.45})`;
      ctx.lineWidth=2;
      ctx.setLineDash([6,4]);
      ctx.stroke();
      ctx.setLineDash([]);
    }
    ctx.restore();

    const bw = e.type==="boss"?66:34;
    const r=e.hp/e.maxHp;
    ctx.fillStyle="rgba(0,0,0,0.6)";
    ctx.fillRect(e.x-bw/2, e.y-36, bw, 5);
    ctx.fillStyle="#4af2c5";
    ctx.fillRect(e.x-bw/2, e.y-36, bw*Math.max(0,r), 5);
  }

  // enemy towers (red hex)
  for(const tw of enemyTowers){
    ctx.save();
    ctx.translate(tw.x, tw.y);

    ctx.beginPath();
    ctx.arc(0,0,tw.range,0,Math.PI*2);
    ctx.strokeStyle="rgba(255,75,129,0.06)";
    ctx.lineWidth=1;
    ctx.stroke();

    ctx.rotate(tw.spin);
    ctx.shadowColor="rgba(255,75,129,0.9)";
    ctx.shadowBlur=16;

    const r=18;
    ctx.beginPath();
    for(let i=0;i<6;i++){
      const a=(Math.PI*2/6)*i;
      const x=Math.cos(a)*r;
      const y=Math.sin(a)*r;
      if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    }
    ctx.closePath();
    ctx.fillStyle="rgba(255,75,129,0.88)";
    ctx.fill();
    ctx.strokeStyle="rgba(0,0,0,0.35)";
    ctx.lineWidth=2;
    ctx.stroke();
    ctx.restore();

    const bw=34;
    const rr=tw.hp/tw.maxHp;
    ctx.fillStyle="rgba(0,0,0,0.7)";
    ctx.fillRect(tw.x-bw/2, tw.y+22, bw, 4);
    ctx.fillStyle = rr>0.35 ? "#ffb3c7" : "#ff4b81";
    ctx.fillRect(tw.x-bw/2, tw.y+22, bw*Math.max(0,rr), 4);
  }

  // player towers (cyan circles)
  for(const t of towers){
    ctx.save();
    ctx.translate(t.x,t.y);

    ctx.beginPath();
    ctx.arc(0,0,t.range,0,Math.PI*2);
    ctx.strokeStyle="rgba(90,140,255,0.08)";
    ctx.lineWidth=1;
    ctx.stroke();

    ctx.beginPath();
    ctx.arc(0,0,20,0,Math.PI*2);

    const grad = ctx.createRadialGradient(0,0,0,0,0,20);
    if(t.typeId==="rail"){ grad.addColorStop(0,"#fff"); grad.addColorStop(0.5,"#57f2ff"); grad.addColorStop(1,"#1b2460"); }
    else if(t.typeId==="missile"){ grad.addColorStop(0,"#ffe082"); grad.addColorStop(0.5,"#ff7043"); grad.addColorStop(1,"#351318"); }
    else if(t.typeId==="slow"){ grad.addColorStop(0,"#e0e0ff"); grad.addColorStop(0.5,"#7e57c2"); grad.addColorStop(1,"#2a1748"); }
    else if(t.typeId==="pulse"){ grad.addColorStop(0,"#fff3e0"); grad.addColorStop(0.5,"#ffca28"); grad.addColorStop(1,"#4e342e"); }
    else if(t.typeId==="poison"){ grad.addColorStop(0,"#e8f5e9"); grad.addColorStop(0.5,"#81c784"); grad.addColorStop(1,"#1b5e20"); }
    else if(t.typeId==="heal"){ grad.addColorStop(0,"#e0fff4"); grad.addColorStop(0.5,"#66ffc4"); grad.addColorStop(1,"#184636"); }
    else if(t.typeId==="tachyon"){ grad.addColorStop(0,"#ffffff"); grad.addColorStop(0.5,"#c8ffff"); grad.addColorStop(1,"#2b2f66"); }
    else { grad.addColorStop(0,"#4af2c5"); grad.addColorStop(0.6,"#1d8cff"); grad.addColorStop(1,"rgba(10,10,40,0.6)"); }

    ctx.fillStyle=grad;
    ctx.shadowColor="#4af2c5";
    ctx.shadowBlur=18;
    ctx.fill();

    ctx.rotate(t.spin);
    ctx.beginPath();
    ctx.arc(0,0,12,0,Math.PI*2);
    ctx.strokeStyle="rgba(250,255,255,0.92)";
    ctx.lineWidth=2;
    ctx.setLineDash([6,4]);
    ctx.stroke();
    ctx.setLineDash([]);
    ctx.restore();

    const bw=32;
    const rr=t.hp/t.maxHp;
    ctx.fillStyle="rgba(0,0,0,0.7)";
    ctx.fillRect(t.x-bw/2, t.y+22, bw, 4);
    ctx.fillStyle = rr>0.4 ? "#4af2c5" : "#ff4b81";
    ctx.fillRect(t.x-bw/2, t.y+22, bw*Math.max(0,rr), 4);
  }

  // allies (clearly different: bright cyan + white outline + icon)
  for(const a of allies){
    ctx.save();
    ctx.translate(a.x,a.y);
    const from=pathPoints[a.pathIndex];
    const to=pathPoints[Math.max(0,a.pathIndex-1)]||from;
    const ang=Math.atan2(to.y-from.y,to.x-from.x);
    ctx.rotate(ang);

    ctx.shadowBlur=18;
    ctx.shadowColor="rgba(100,220,255,0.95)";

    const size =
      (a.typeId==="sniperU") ? 16 :
      (a.typeId==="bomberU") ? 18 :
      (a.typeId==="guardian") ? 20 : 15;

    // body triangle
    ctx.beginPath();
    ctx.moveTo(size,0);
    ctx.lineTo(-size*0.8,-size*0.7);
    ctx.lineTo(-size*0.8, size*0.7);
    ctx.closePath();
    ctx.fillStyle="rgba(120,220,255,0.98)";
    ctx.fill();

    // outline
    ctx.strokeStyle="rgba(255,255,255,0.55)";
    ctx.lineWidth=2;
    ctx.stroke();

    // medic cross
    if(a.typeId==="medicU"){
      ctx.beginPath(); ctx.rect(-5,-8,10,16); ctx.rect(-8,-5,16,10);
      ctx.fillStyle="rgba(74,242,197,0.95)";
      ctx.fill();
    }
    // guardian shield mark
    if(a.typeId==="guardian"){
      ctx.beginPath();
      ctx.arc(-2,0,6,0,Math.PI*2);
      ctx.fillStyle="rgba(255,255,255,0.35)";
      ctx.fill();
    }
    // emp mark
    if(a.typeId==="emp"){
      ctx.beginPath();
      ctx.moveTo(-4,-8); ctx.lineTo(2,-2); ctx.lineTo(-2,-2); ctx.lineTo(4,8); ctx.lineTo(-2,2); ctx.lineTo(2,2);
      ctx.closePath();
      ctx.fillStyle="rgba(144,202,249,0.85)";
      ctx.fill();
    }

    ctx.restore();

    const bw=34;
    const rr=a.hp/a.maxHp;
    ctx.fillStyle="rgba(0,0,0,0.65)";
    ctx.fillRect(a.x-bw/2, a.y-34, bw, 4);
    ctx.fillStyle="rgba(100,220,255,0.98)";
    ctx.fillRect(a.x-bw/2, a.y-34, bw*Math.max(0,rr), 4);
  }

  // hover tile hint
  if(mouse.tx>=0 && mouse.ty>=0){
    const x=mouse.tx*TILE, y=mouse.ty*TILE;
    ctx.save();
    ctx.beginPath();
    ctx.rect(x+1,y+1,TILE-2,TILE-2);
    const ok=mouse.ok;
    const isUnit = (mode==="unit");
    ctx.fillStyle = ok
      ? (isUnit ? "rgba(100,220,255,0.14)" : "rgba(74,242,197,0.16)")
      : "rgba(255,75,129,0.13)";
    ctx.strokeStyle = ok
      ? (isUnit ? "rgba(100,220,255,0.75)" : "rgba(74,242,197,0.75)")
      : "rgba(255,75,129,0.75)";
    ctx.lineWidth=2.0;
    ctx.fill();
    ctx.stroke();
    ctx.restore();
  }

  resetTransform();
}

function drawOverlay(){
  resetTransform();
  if(gameOver || victory){
    ctx.save();
    ctx.fillStyle="rgba(5,0,20,0.80)";
    ctx.fillRect(0,0,CW,CH);

    ctx.textAlign="center";
    ctx.fillStyle = victory ? "#4af2c5" : "#ff4b81";
    ctx.font="900 54px system-ui";
    ctx.fillText(victory ? "MISSION CLEAR" : "MISSION FAILED", CW/2, CH/2 - 18);

    ctx.fillStyle="#f4f8ff";
    ctx.font="16px system-ui";
    ctx.fillText("R í‚¤/ë²„íŠ¼ìœ¼ë¡œ ì¬ì‹œì‘ Â· ë§µ ì„ íƒì—ì„œ ë‹¤ìŒ ì§„í–‰", CW/2, CH/2 + 22);
    ctx.restore();
  }else{
    // small HUD
    ctx.save();
    ctx.fillStyle="rgba(0,0,0,0.25)";
    ctx.fillRect(12, 12, 260, 74);
    ctx.strokeStyle="rgba(110,144,255,0.35)";
    ctx.strokeRect(12,12,260,74);
    ctx.fillStyle="#eaf0ff";
    ctx.font="12px system-ui";
    ctx.fillText(`ëª¨ë“œ: ${mode==="tower"?"ì„¤ì¹˜":"ì†Œí™˜"} Â· ì›¨ì´ë¸Œ: ${waveInProgress?"ì§„í–‰":"ëŒ€ê¸°"}`, 22, 36);
    ctx.fillStyle="rgba(255,255,255,0.75)";
    ctx.fillText(`RED ë°©ì–´ìì›: ${Math.floor(redEnergy)}`, 22, 56);
    ctx.fillText(`íŒ: +ì†Œí™˜ì€ ì›¨ì´ë¸Œ ì¤‘ì—ë§Œ`, 22, 74);
    ctx.restore();
  }
}

function loop(){
  tick++;

  if(!gameOver && !victory){
    updateEnemies();
    updateEnemyTowers();
    updateAllies();
    updateTowers();
    updateProjectiles();
    updatePulses();
  }

  refreshUI();
  drawBackground();
  drawWorld();
  drawOverlay();

  requestAnimationFrame(loop);
}

/* input / hover / tap */
function computeHover(clientX,clientY){
  const {sx,sy}=clientToCanvas(clientX,clientY);
  const w=screenToWorld(sx,sy);
  const tx0=Math.floor(w.x/TILE);
  const ty0=Math.floor(w.y/TILE);

  if(!isInside(tx0,ty0)){
    mouse.tx=-1; mouse.ty=-1; mouse.ok=false;
    return;
  }

  if(mode==="unit"){
    // for unit: nearest path index
    const pi=findNearestPathIndex(tx0,ty0,4);
    if(pi>=0){
      const pt=pathTiles[pi];
      mouse.tx=pt.x; mouse.ty=pt.y; mouse.ok=true;
    }else{
      mouse.tx=tx0; mouse.ty=ty0; mouse.ok=false;
    }
  }else{
    // for tower: nearest valid empty
    const p=findNearestValidTowerTile(tx0,ty0,3);
    if(p){ mouse.tx=p.tx; mouse.ty=p.ty; mouse.ok=true; }
    else { mouse.tx=tx0; mouse.ty=ty0; mouse.ok=false; }
  }
}

function handleTap(clientX,clientY){
  if(gameOver||victory) return;

  const {sx,sy}=clientToCanvas(clientX,clientY);
  const w=screenToWorld(sx,sy);
  const tx0=Math.floor(w.x/TILE);
  const ty0=Math.floor(w.y/TILE);
  if(!isInside(tx0,ty0)) return;

  if(mode==="unit"){
    const pi=findNearestPathIndex(tx0,ty0,5);
    if(pi<0){ setStatus("ì†Œí™˜ ëª¨ë“œ: ê²½ë¡œ(ê¸¸) ê·¼ì²˜ë¥¼ íƒ­í•˜ì„¸ìš”.", "warn"); return; }
    spawnAllyAtPathIndex(pi);
  }else{
    const p=findNearestValidTowerTile(tx0,ty0,4);
    if(!p){ setStatus("ì„¤ì¹˜ ê°€ëŠ¥í•œ ì¹¸ì´ ì—†ìŠµë‹ˆë‹¤(ì£¼ë³€).", "warn"); return; }
    placeTowerAtTile(p.tx,p.ty);
  }
}

/* pan / zoom */
let isPanning=false;
let panStart={sx:0,sy:0,ox:0,oy:0};
function startPan(clientX,clientY){
  const {sx,sy}=clientToCanvas(clientX,clientY);
  isPanning=true;
  panStart={sx,sy,ox:view.ox,oy:view.oy};
}
function movePan(clientX,clientY){
  if(!isPanning) return;
  const {sx,sy}=clientToCanvas(clientX,clientY);
  view.ox = panStart.ox + (sx - panStart.sx);
  view.oy = panStart.oy + (sy - panStart.sy);
  clampCamera();
}
function endPan(){ isPanning=false; }

canvas.addEventListener("mousemove",(e)=>computeHover(e.clientX,e.clientY));
canvas.addEventListener("mouseleave",()=>{mouse.tx=-1; mouse.ty=-1; mouse.ok=false;});

let dragging=false;
let downPos=null;
const dragThreshold=7;

canvas.addEventListener("mousedown",(e)=>{
  downPos={x:e.clientX,y:e.clientY};
  dragging=false;
  startPan(e.clientX,e.clientY);
});
window.addEventListener("mousemove",(e)=>{
  if(!isPanning) return;
  const dx=Math.abs(e.clientX-downPos.x), dy=Math.abs(e.clientY-downPos.y);
  if(dx+dy>dragThreshold) dragging=true;
  movePan(e.clientX,e.clientY);
});
window.addEventListener("mouseup",()=>{ if(isPanning) endPan(); });

canvas.addEventListener("click",(e)=>{
  if(dragging) return;
  computeHover(e.clientX,e.clientY);
  handleTap(e.clientX,e.clientY);
});

canvas.addEventListener("wheel",(e)=>{
  const {sx,sy}=clientToCanvas(e.clientX,e.clientY);
  const before=screenToWorld(sx,sy);
  const factor = e.deltaY>0 ? 0.92 : 1.08;
  view.scale = clamp(view.scale*factor, 0.22, 1.55);
  view.ox = sx - before.x*view.scale;
  view.oy = sy - before.y*view.scale;
  clampCamera();
  e.preventDefault();
},{passive:false});

// touch: 1-finger pan/tap, 2-finger pinch
let touchMode="none";
let lastTouch=null;
let pinchStart=null;

canvas.addEventListener("touchstart",(e)=>{
  if(e.touches.length===1){
    const t=e.touches[0];
    lastTouch={x:t.clientX,y:t.clientY};
    startPan(t.clientX,t.clientY);
    touchMode="pan";
    computeHover(t.clientX,t.clientY);
  }else if(e.touches.length===2){
    touchMode="pinch";
    const a=e.touches[0], b=e.touches[1];
    const dx=a.clientX-b.clientX, dy=a.clientY-b.clientY;
    pinchStart={ dist:Math.sqrt(dx*dx+dy*dy), scale:view.scale };
  }
  e.preventDefault();
},{passive:false});

canvas.addEventListener("touchmove",(e)=>{
  if(touchMode==="pan" && e.touches.length===1){
    const t=e.touches[0];
    movePan(t.clientX,t.clientY);
    computeHover(t.clientX,t.clientY);
  }else if(touchMode==="pinch" && e.touches.length===2){
    const a=e.touches[0], b=e.touches[1];
    const dx=a.clientX-b.clientX, dy=a.clientY-b.clientY;
    const d=Math.sqrt(dx*dx+dy*dy);
    const ratio = d/(pinchStart?.dist||d);
    view.scale = clamp((pinchStart?.scale||view.scale)*ratio, 0.22, 1.55);
    clampCamera();
  }
  e.preventDefault();
},{passive:false});

canvas.addEventListener("touchend",(e)=>{
  if(touchMode==="pan"){
    const changed=e.changedTouches && e.changedTouches[0];
    if(changed && lastTouch){
      const dx=Math.abs(changed.clientX-lastTouch.x);
      const dy=Math.abs(changed.clientY-lastTouch.y);
      if(dx+dy<10){
        computeHover(changed.clientX,changed.clientY);
        handleTap(changed.clientX,changed.clientY);
      }
    }
  }
  endPan();
  touchMode="none";
  lastTouch=null;
  pinchStart=null;
  e.preventDefault();
},{passive:false});

/* keys */
document.addEventListener("keydown",(e)=>{
  const k=e.key;
  if(k==="r"||k==="R"){
    resetGameStateOnly();
    placeInitialEnemyTowers();
    setStatus("ì¬ì‹œì‘!", "good");
    return;
  }
  if(k===" "){
    // space toggles mode
    if(mode==="tower") setMode("unit"); else setMode("tower");
    return;
  }
  if(k>="1" && k<="9"){
    const idx=parseInt(k,10)-1;
    if(idx>=0 && idx<towerTypes.length){
      selectedTowerIndex=idx;
      buildTowerBar();
      setStatus(`íƒ€ì›Œ ì„ íƒ: ${towerTypes[idx].name}`, "good");
    }
    return;
  }
  const uk=k.toUpperCase();
  const hot = unitTypes.findIndex(u=>u.hotkey===uk);
  if(hot>=0){
    selectedUnitIndex=hot;
    buildUnitBar();
    setStatus(`ìœ ë‹› ì„ íƒ: ${unitTypes[hot].name}`, "good");
    return;
  }
});

/* buttons */
function setMode(m){
  mode=m;
  if(mode==="tower"){
    modeTowerBtn.classList.add("on");
    modeUnitBtn.classList.remove("on");
    setStatus("ì„¤ì¹˜ ëª¨ë“œ: ë¹ˆì¹¸ íƒ­ìœ¼ë¡œ íƒ€ì›Œ ì„¤ì¹˜", "good");
  }else{
    modeUnitBtn.classList.add("on");
    modeTowerBtn.classList.remove("on");
    setStatus("ì†Œí™˜ ëª¨ë“œ: ì›¨ì´ë¸Œ ì¤‘ ê²½ë¡œ íƒ­ ë˜ëŠ” +ì†Œí™˜", "good");
  }
}

startWaveBtn.addEventListener("click", ()=> createWave());
restartBtn.addEventListener("click", ()=>{
  resetGameStateOnly();
  placeInitialEnemyTowers();
  setStatus("ì¬ì‹œì‘!", "good");
});
storyBtn.addEventListener("click", ()=> showStory(currentEp));
closeStoryBtn.addEventListener("click", hideStory);
if(epilogueBtn){
  epilogueBtn.addEventListener("click", ()=>fadeTo("ep.html"));
}

modalBack.addEventListener("click",(e)=>{ if(e.target===modalBack) hideStory(); });

modeTowerBtn.addEventListener("click", ()=> setMode("tower"));
modeUnitBtn.addEventListener("click", ()=> setMode("unit"));

spawnBtn.addEventListener("click", ()=>{
  // ë²„íŠ¼ ì†Œí™˜ì€ "ë‚´ ê¸°ì§€ ê·¼ì²˜(ë ìª½)" ê¸°ë³¸
  const pi = Math.max(0, pathPoints.length-1);
  spawnAllyAtPathIndex(pi);
});

mapSelect.addEventListener("change", ()=>{
  const [eidx, midx] = mapSelect.value.split(":").map(x=>parseInt(x,10));
  initMapByEpAndIndex(eidx, midx, true);
});

/* boot */
async function boot(){
  [towerTypes, enemyTowerTypes, enemyConfigs, unitTypes, episodes, maps] = await Promise.all([
    fetch(URLS.towers).then(r=>r.json()),
    fetch(URLS.enemyTowers).then(r=>r.json()),
    fetch(URLS.enemies).then(r=>r.json()),
    fetch(URLS.units).then(r=>r.json()),
    fetch(URLS.episodes).then(r=>r.json()),
    fetch(URLS.maps).then(r=>r.json())
  ]);

  // ensure progress keys exist
  const prog = loadProgress();
  if(prog.unlockedMapByEpisode==null) prog.unlockedMapByEpisode={"0":0};
  if(prog.unlockedMapByEpisode["0"]==null) prog.unlockedMapByEpisode["0"]=0;
  saveProgress(prog);

  buildTowerBar();
  buildUnitBar();

  // initialize canvas sizing AFTER layout
  requestAnimationFrame(()=>{
    resizeCanvas();
    initStars();

    // start at latest unlocked episode/map
    const ue = clamp(prog.unlockedEpisode ?? 0, 0, episodes.length-1);
    const um = clamp((prog.unlockedMapByEpisode[String(ue)] ?? 0), 0, 2);

    rebuildMapSelect();
    initMapByEpAndIndex(ue, um, true);

    setMode("tower");
    setStatus("ëŒ€ê¸° ìƒíƒœ: â–¶ ì›¨ì´ë¸Œ ì‹œì‘ì„ ëˆŒëŸ¬ ì§„í–‰í•˜ì„¸ìš”.", "good");
    loop();
  });
}
boot();
</script>
</body>
</html>
